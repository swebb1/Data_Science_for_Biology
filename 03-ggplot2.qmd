---
title: "ggplot2"
---

<head>

```{=html}
<script src="https://kit.fontawesome.com/ece750edd7.js" crossorigin="anonymous"></script>
```

</head>

```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

::: objectives
<h2><i class="far fa-check-square"></i> Learning Objectives</h2>

-   Build graphics layer by layer with ggplot2
-   Create different types of graphics by applying geometries
-   Apply additional layers to a graphic
-   Visually subset graphics by applying fills and gradients
-   Change the appearance of graphics using themes
-   Create sub-graphics by applying facets
-   Create and save basic graphics
-   Use additional libraries such as `plotly` to enhance the utility of graphics.
:::

<br>

`ggplot2` is a plotting package that makes it simple to create complex graphics from data frames. It provides a grammar for specifying which variables to plot, how they are displayed, and general visual properties. 

First, make sure you load all of the required libraries and datasets. There are quite a few new libraries here and we will explain them as we go.

```{r}
library(tidyverse)
library(ggthemes)
library(plotly)
library(ggrepel)
library(ggpubr)
library(viridis)
library(RColorBrewer)
library(ggsci)
library(patchwork)
library(gghighlight)

#This dataset is built in to R
data(iris)

#Import from url
surveys <- read_csv("http://bifx-core3.bio.ed.ac.uk/training/DSB/data/surveys_complete.csv") 
```

## Fisher's Iris dataset (pre-installed in R)

![](images/iris.png)

Fisher examined the length and width of petals and sepals in irises to determine a species classification algorithm. Here we will explore the relationship between species and the dimensions of the flowers via the ggplot2 plotting package. Fisher's data is stored as a built in data set in R. To see the data type:

```{r}
head(iris)
```

This data frame has two types of data, continuous and discrete.

```{r}
str(iris)
```

The continuous data is of type *number* and the discrete data is of type *factor*, which can be one of the 3 species:

```{r}
levels(iris$Species)
```

The `summary()` function gives a summary of data in a column. For factors it will give us the count for each categorical variable.

```{r}
summary(iris$Species)
```

We can also use run `summary()` on an entire dataframe or tibble. Take a look at the different column types.

```{r}
summary(iris)
```

## Building a ggplot

ggplot graphics are built step by step by adding new elements. This layered approach allows for extensive flexibility and customisation of plots. To build a ggplot, we use the following basic template:

```{r, eval=FALSE}
ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) + <GEOM_FUNCTION>()
```

Let's explore the iris dataset with ggplot. Use the `ggplot()` function and bind the plot to a specific data frame using the **data** argument.

```{r}
ggplot(data = iris)
```

Our plot is completely empty! This is because we haven't specified what to plot yet.

Next, we define a **mapping**. The mapping argument tells ggplot which variables in the data frame to map to visual *aesthetics* of the plot. We use the `aes()` function to do this. 

The mapping is defined by selecting an aesthetic (e.g. x/y positions or characteristics such as size, shape, color, etc.) and assigning a variable from the data frame to it. 

For example, to map the `Sepal.Length` variable to the x-axis and `Sepal.Width` to the y-axis we would use:

```{r}
ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width))
```

Now we have axes and a grid, but still no data! We still need to tell ggplot how to represent the data on the plot. This is done by adding a **geometry** to the plot.

Geometries are graphical representations of the data (points, lines, bars etc). The ggplot2 package offers many different `geom_*()` functions, here are a few commonly used examples:

-   `geom_point()` for scatter plots, dot plots, etc.
-   `geom_histogram()` for histograms
-   `geom_bar()` or `geom_col()` for bar plots
-   `geom_boxplot()` for, well, boxplots!
-   `geom_line()` for trend lines, time series, etc.

## Scatterplots

To add a geom to the plot use the + operator. Let's use `geom_point()` to plot two continuous variables first. The **data** and **mapping** are always the first two arguments to ggplot so we can leave these out if arguments are provided in this order:

```{r}
ggplot(iris,aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point()
```

The `+` in the ggplot2 package is particularly useful because it allows us to modify existing ggplot objects. This means we can easily set up plot templates and conveniently explore different types of plots, so the above plot can also be generated with code like this:

```{r}
# Assign plot to a variable
p <- ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width))

# Draw a scatter plot
p + geom_point()
```

The `geom_point()` function has many options to customise the plot, for example we can change the colour of the points:

```{r}
p + geom_point(colour = "red")
```

This isn't very informative though. It would be better if we could make the points different colours depending on which *species* they belong to. We can do this by mapping the `colour` aesthetic to the `Species` variable in our data frame.

```{r}
p <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, colour = Species))
p + geom_point()
```

Anything you put in the `ggplot()` function is inherited by subsequent layers. If you want to specify mappings for a given geom independently, you can add these within a geom instead. 

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + 
  geom_point(aes(colour = Species))
```

This is really useful when we want to plot multiple *geoms* on the same graph with different aesthetics. Let's add a second layer of points with a different shape and size to the plot.

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + 
  geom_point(aes(colour = Species)) +
  geom_point(shape=2, size = 8)
```

Only the first layer is coloured by species. If we move the colour aesthetic to the ggplot function, both layers will be coloured by species:

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, colour=Species)) + 
  geom_point() +
  geom_point(shape=2, size = 8)
```

In the `aes()` function, `colour` is used assign colours for *lines* and *points*. If you want to colour shapes such as bars in barplots and histograms you need to use `fill`.

Each function within the ggplot package has its own help file associated with it.

```{r, eval=FALSE}
?geom_point()
```

Note that all the geometries also define a statistical transformation. In the help file of geom_point you'll see `stat = "identity"`. This means that `geom_point()` plots the raw values by default. Other geometries have different defaults, for instance `geom_histogram()` bins values together.

## Histograms

Here is an example of the histogram geometry:

```{r}
#Visualise the distribution of Sepal.Width with a histogram
h <- ggplot(iris, aes(Sepal.Width, fill = Species )) +  
  geom_histogram(binwidth = 0.1)

h
```

::: discussion
<h2><i class="far fa-bell"></i> Discussion</h2>

Try altering the `binwidth` parameter to see how this affects the plot.
:::

<br>

:::: challenge
<h2><i class="fas fa-pencil-alt"></i> Challenge:</h2>

Use what you have learned to create a scatterplot of Sepal.Width per Species.

<details>

<summary>

</summary>

::: solution
<h2><i class="far fa-eye"></i> Solution:</h2>

```{r,  purl=FALSE}
ggplot(iris, aes(x=Species, y=Sepal.Width )) + geom_point() 
```
:::

</details>
::::

From the plots above, we can see a *distribution* of Sepal.Width values for each species. The histogram is good for showing the distribution, but the overlap makes it difficult to compare between species.

The scatterplot separates our species better, but it's difficult to visualise the distribution and impossible to tell how many data points overlap. **Boxplots** and **violin plots** are good alternatives for visualising distributions of data within groups.

## Boxplots

Boxplots are an effective way to visualise distributions of data within groups. 

!!! INFO BOX!!!

The boxplot geometry requires the `x` aesthetic to be a *categorical* variable and the `y` aesthetic to be *numerical*.

```{r}
b <- ggplot(iris, aes(x=Species, y=Sepal.Width )) +  geom_boxplot() 
b
```

To flip the axes we can use another function called `coord_flip()`.

```{r}
b + coord_flip()
```

It would be more visually appealing to have the species ordered by the median sepal width, so that our plot is ordered from smallest to largest.

We can reorder aesthetics in ggplot by using the `fct_reorder()` function from the **forcats** package. This function takes a factor (categorical variable) and a numeric variable and reorders the factor levels based on the values of the numeric variable.

The **forcats** package is also a part of the **tidyverse** and has a lot of functions for ordering, labeling and manipulating factors.

```{r}
b <- ggplot(iris, aes(x = fct_reorder(Species,Sepal.Width), y=Sepal.Width )) + 
  geom_boxplot()

b
```

We probably want to relabel the x-axis now:

```{r}
b <- b + xlab("Species")
b
```

## Adding layers

Adding points to a boxplot gives a better representation of the number of measurements and their distribution.

```{r}
b + geom_point(colour = "forest green")
```

This is okay, but we know there are some dots where values overlap and it's difficult to see how many data points we really have. We can use the `alpha` option within our geometry to increase transparency.

```{r}
b + geom_point(colour="forest green",alpha=0.3)
```

This is slightly better, we can see that darker points have more overlap, but it isn't great. The `geom_jitter()` function is a good alternative to `geom_point()` in this example as it randomly *shifts* data points to avoid overlap. We can colour by Species so there is no confusion between plots.

```{r}
b + geom_jitter(aes(colour = Species))
```

## Violin plots

::::: challenge
<h2><i class="fas fa-pencil-alt"></i> Challenge:</h2>

Boxplots are useful summaries but can hide the shape of non-normal distributions. For example, if the distribution is bimodal, we would not see it in a boxplot. An alternative to the boxplot is the violin plot, where the shape of the density of points is drawn.

Replace the box plot with a violin plot; see `geom_violin()`.

<details>

<summary>

</summary>

::: solution
<h2><i class="far fa-eye"></i> Solution:</h2>

```{r,  purl=FALSE}
ggplot(iris, aes(x = fct_reorder(Species, Sepal.Width), y = Sepal.Width, fill = Species )) + 
  geom_violin() +
  xlab("Species") 
```
:::

</details>

Can you add a boxplot and datapoints over the violin plot?

<details>

<summary>

</summary>

::: solution
<h2><i class="far fa-eye"></i> Solution:</h2>

```{r,  purl=FALSE}
ggplot(iris, aes(x = fct_reorder(Species, Sepal.Width), y = Sepal.Width)) + 
  geom_violin(aes(fill = Species),alpha=0.3)+ 
  geom_boxplot()+
  geom_jitter(aes(colour = Species))+
  xlab("Species") 
```
:::

</details>
:::::

## Themes

Let's return to our scatter plot and play around with plotting **themes**. Themes are a set of pre-defined settings that control the overall appearance of a plot, including background color, grid lines, font size, and more. Pre-set themes allow you to quickly change the look of your plot without having to manually adjust each individual element.

```{r}
p <- ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) +  geom_point()
```

We can continue to modify this scatter plot. Let's make the axis a bit prettier with the xlab() and ylab() functions:

```{r, error=T}
p <- p + xlab("Sepal length") + ylab("Sepal width") 
p
```

All the characteristics of the plot, such as text size and the background are managed by the function called theme(). To see what a theme can change:

```{r}
?theme
```

You can use a theme with predefined defaults e.g:

```{r}
p + theme_dark() #Dark theme
#OR
p + theme_bw() #Black and white theme
```

You can also try `theme_light`, `theme_minimal`, `theme_void`, or create you own from scratch:

```{r}
p + theme(
    		panel.background = element_blank(), 
     		panel.grid.major = element_line(colour = "darkgrey"), 
     		text = element_text(size=20), 
     		axis.title.x=element_blank(), 
     		axis.title.y=element_blank()
    		)

# Note you can save your theme and reuse it 
theme_for_nature <- theme(
    		panel.background = element_blank(), 
     		panel.grid.major = element_line(colour = "darkgrey"), 
     		text = element_text(size=20), 
     		axis.title.x=element_blank(), 
     		axis.title.y=element_blank() 
    		)
```

We can then reuse a theme, for example on the histogram we made earlier.

```{r}
h + theme_for_nature
```

The ggplot package has a lot of built in themes. Try typing "theme\_" and give some of them a try. The `ggthemes` and `ggpubr` packages also contain a selection of prebuilt themes e.g:

```{r}
library(ggthemes)
p + theme_fivethirtyeight()
```

We can set a default theme to use in all ggplots:

```{r}
theme_set(theme_bw())
```

We can also use a base theme and customise specific settings.

```{r}
theme_set(theme_bw(base_size = 12))
```

## Adding colours to plots

As we have seen, points, lines and shapes can be coloured by a value in your data frame using the `aes()` function. Earlier we coloured by a factor but we can also colour by a continuous value which will create a gradient of colour. Lets look at the Petals this time and colour by the ratio of Sepal.Length to Sepal.Width:

First, create a new version of the iris dataset with a new column called `Sepal.Ratio`:

```{r,echo=F}
iris2 <- iris |> mutate(Sepal.Ratio = Sepal.Length / Sepal.Width)
iris2 |> head()
```

Now create a scatter plot of Petal.Length vs Petal.Width and colour by Sepal.Ratio:

```{r}
q <- ggplot(iris2, aes(x = Petal.Length, y = Petal.Width, colour = Sepal.Ratio)) +
  geom_point(alpha=0.5)
q
```

Because the colour is mapped to a continuous variable, ggplot has automatically created a gradient of colour.

To change the default colours, we use the `scale_color_*` functions of which there are many. Some are built into **ggplot2** and others exist in external packages such as **viridis** or **ggthemes**. The [viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) and [ColorBrewer](https://www.datanovia.com/en/blog/the-a-z-of-rcolorbrewer-palette/) palettes are particularly useful and worth investigating. The [ggsci](https://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html) package contains palettes based on key scientific journals.

!!!!! Viridis colour blind, data visualisation tricks and tips

### Continuous scales

Try the different scale options in the code below:

```{r}
library(viridis)
library(RColorBrewer)

#default
q + scale_colour_continuous()
#ColorBrewer palletes (many to choose from)
q + scale_colour_distiller(palette = "Spectral")
#Viridis colour scales (many to choose from)
q + scale_colour_viridis()
```

An alternative method is to use the `scale_colour_gradient*` functions to define your own gradient e.g:

```{r}
q + scale_color_gradient2(high = "darkred", low = "white",  mid = "red", midpoint=2)
```

### Discrete scales

There are also colour scales for discrete variables. Note that we must use `fill` for colouring boxes.

```{r}
bp <- ggplot(iris2, aes(Species, Sepal.Length, fill = Species)) +
  geom_boxplot()

#Default
bp + scale_fill_discrete()
#Viridis
bp + scale_fill_viridis(discrete = TRUE)
#ColorBrewer Palettes
bp + scale_fill_brewer(palette = "Dark2")
#GGSci - Nature publishing group
library(ggsci)
bp + scale_fill_npg()
```

Alternatively you can manually choose your own colours with `scale_fill_manual()`:

```{r}
h + scale_fill_manual(values = c("forest green", "dodger blue", "firebrick"))
```

You can also use hex codes for colours:

```{r}
h + scale_fill_manual(values = c("#DDDD33","#EE3344", "#1133FF"))
```

::: resources
<h2><i class="fas fa-book"></i> Further Learning</h2>

The options for colouring graphs are huge.

-   [Color brewer 2](http://colorbrewer2.org) is a great site for getting the hex values of colours to suit needs such as printer or colour blind friendliness.
-   [Coolors](http://coolors.co) and [Colormind](http://colormind.io/) are colour palette generators.
:::

## Adding more variables

Take a look at this example:

```{r, eval=F}
ggplot(iris2, aes(x=Petal.Length, y=Petal.Width, colour=Sepal.Ratio)) +
  geom_point()
```

:::: challenge
<h2><i class="fas fa-pencil-alt"></i> Challenge:</h2>

See if you can represent some of the other variables from the iris dataset in this plot as well. **Hint:** There are several other aesthetic mappings such as `size` and `shape`.

<details>

<summary>

</summary>

::: solution
<h2><i class="far fa-eye"></i> Solution:</h2>

```{r,  purl=FALSE}
ggplot(iris2, aes(x = Petal.Length, y = Petal.Width, colour = Sepal.Ratio, shape = Species, size = Sepal.Length)) +
  geom_point(alpha=0.5) +
  theme_bw()
```
:::

</details>
::::

## Faceting

When we have defined groups within our data, we can split our data into separate plots by using `facets`.

Let's look at plot q again.

```{r}
q
```

Let's split this plot by species. This is achieved using either the `facet_grid()` or `facet_wrap()` functions:

```{r}
q + facet_wrap(~Species, nrow = 1, scales = "fixed")
```

Try playing around with the `nrow` and `scales` parameters in `facet_wrap()`.

Note that the facet variable is preceded by the <key>\~</key> character. This is used to define formulas in R and is a common way to specify the variable to facet by. 

The `facet_wrap()` function is useful when you are splitting by one factor, whereas the `facet_grid()` function is useful when you are splitting by multiple factors. Let's add another categorical variable to `iris2`. We can randomly assign a *country*, one of four nations of origin, to each observation:

```{r}
countries <- c("Italy", "Spain", "France", "UK")

#Sample will randomly select a value for each row
iris2 <- iris2 |> mutate(Country = sample(countries, nrow(iris2), replace = TRUE))

iris2 |> head()
```

Now we can facet by both country and species:

```{r}
q2 <- ggplot(iris2, aes(x = Petal.Length, y = Petal.Width, colour = Sepal.Ratio)) +
  geom_point()
q2 + facet_grid(Country ~ Species)
```

:::: challenge
<h2><i class="fas fa-pencil-alt"></i> Challenge:</h2>

Use dplyr and ggplot to display the mean petal length for each species in each country except for those found in France. Use colouring and faceting to enhance the plot.

<details>

<summary>

</summary>

::: solution
<h2><i class="far fa-eye"></i> Solution:</h2>

```{r,  purl=FALSE}
iris2 |>
filter(Country != "France") |> 
group_by(Species, Country) |>
summarise(Mean = mean(Petal.Length)) |> 
ggplot(aes(x = Country, y = Mean, colour = Species)) + 
  geom_point(size = 4) + 
  facet_wrap(~Species) + 
  labs(title="Mean Petal Length")
```
:::

</details>
::::

## Adding labels

You can add labels to points in your graphs. One of the best ways to do this is to use the package `ggrepel`.

```{r}
library(ggrepel)
# you can use geom_text_repel() or geom_label_repel() to label whatever you want with non-overlapping labels. In the brackets use conditional subsetting to only label the interesting elements of your data.

ggplot(iris2, aes(Petal.Width, Petal.Length, colour = Sepal.Ratio)) +
  geom_point() +
  geom_label_repel(aes(label = ifelse(Petal.Length > 6.4 ,as.character(Species),'')))
```

### Highlight points or lines

You can choose to highlight specific points or lines using `gghighlight`:

```{r}
library(gghighlight)
ggplot(iris2,aes(Petal.Width, Petal.Length, colour = Sepal.Ratio)) +
  geom_point() +
  gghighlight(Petal.Length > 6.4,label_key = Species)
```

## Saving plots

In RStudio there are many options to save the image. However, if you are are wanting to use ggplot2 in a script, or via web interfaces, you can export a graph using the function `ggsave()`.

```{r, eval=FALSE}
#save a png file 
ggsave("IrisScatterplot.png", p)
#save a pdf file
ggsave("IrisScatterplot.pdf", p)
```

The image format is automatically assigned from the file extension you use in the filename. Within `ggsave()` you can also set the resolution for the image as well as the height and width of the image. See the help page for `ggsave()` for more options.

## Arranging multiple plots

Placing ggplots side by side can be performed with packages like **gridExtra** and **patchwork**. [Patchwork](https://github.com/thomasp85/patchwork) uses simple formulas to arrange ggplots:

```{r}
#| fig-height: 6
#| fig-width: 6
library(patchwork)

## On top
q / bp
```

```{r}
#| fig-height: 3
#| fig-width: 8

## Side by side
q + bp
```

```{r}
#| fig-height: 6
#| fig-width: 8

## 2 plots on top, 1 on bottom
(q + h) / bp
```

```{r}
#| fig-height: 6
#| fig-width: 7

## Collect the guides together on one side
(q + h) / bp + plot_layout(guides = "collect")
```

Use `ggsave` to save the image:

```{r, eval=F}
ggsave("DoublePlot.png",q / bp)
```

## Additional functions to enhance plotting

### Cut functions

The `cut_*` functions in ggplot2 can turn *continuous* data into *discrete* levels so they can be plotted as categorical labels. In this example we create a new column that bins the data into 5 groups of equal size based on `Sepal.Length`:

```{r}
iris2 <- iris2 |> mutate(Sepal.Length.Group = cut_number(Sepal.Length, 5))

iris2 |> head()
```

::: discussion
<h2><i class="far fa-bell"></i> Discussion</h2>
Take a look at the new column `Sepal.Length.Group`. How are the groups defined? What are the cut points for each group?

Have a look at the difference between the `cut_number`, `cut_interval` and `cut_width` functions.

:::

<br>

Let's use the new column to colour our data:

```{r}
ggplot(iris2, aes(Sepal.Length, Sepal.Width, fill = Sepal.Length.Group)) +
  geom_violin() +
  labs(fill = "Sepal length intervals", x = "Sepal length", y = "Sepal width")
```

Note the use of the `labs()` function to change multiple labels at once.

### Scaling data

Let's look at a larger dataset like the `surveys_complete` data we used earlier:

```{r}
ggplot(surveys,aes(weight, hindfoot_length)) +
  geom_point()
```

For axes with large values or very dispersed values it can be useful to rescale using a log axis. This can be done in two ways:

```{r}
## We can transform the x values in our ggplot call:
ggplot(surveys, aes(log10(weight), hindfoot_length)) +
  geom_point()
```

```{r}
## OR we can change the x-axis to a log scale
ggplot(surveys,aes(weight, hindfoot_length)) +
  geom_point() +
  scale_x_log10()
```

::: discussion
<h2><i class="far fa-bell"></i> Discussion</h2>

What is the difference between these three plots?
:::

### Interactive plots with Plotly

[Plotly](https://plot.ly/ggplot2) is an alternative charting library to ggplot2 and has its own set of plotting functions. Because it is designed for the web, it can output dynamic and interactive content. Plotly includes a function to convert ggplots into plotly style widgets.

```{r}
library(plotly)

p2 <- ggplot(iris2, aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) + 
  geom_point()

ggplotly(p2)
```

<br>

With plotly widgets you can:
-   Hover over points to see more information
-   Zoom and pan around the plot
-   Select groups of points by clicking and double-clicking the legend

By default, the hover text is whatever is mapped in the aesthetics. You can add a `text` aesthetic to add this to the tooltip text.

```{r,warning=F}
p2 <- ggplot(iris2, aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) + 
  geom_point(aes(text = Country))

## Show all aesthetics in tooltip
ggplotly(p2)

## Show only the text aesthetic in tooltip
ggplotly(p2, tooltip = "text")

```


Interactive `plotly` graphics are built using html, the language of the web. They open in the *Viewer* pane in Rstudio which is used for web content. 

This means they cannot be saved in static file formats like PDF or PNG. Alternatively you can save them as individual web pages using the `htmlwidgets` package:

```{r eval=F}
htmlwidgets::saveWidget(as_widget(gp2), "plotly_image.html")
```

Alternatively, you can embedded them in `R Markdown` or `quarto` documents, which we will visit later on.

### Interactive graphics with ggiraph

[ggiraph](https://davidgohel.github.io/ggiraph/index.html) is another package that allows you to create interactive graphics. It is particularly useful for creating interactive plots for the web.

Instead of `geom_point()` we use `geom_point_interactive()` from the ggiraph package. We then use the `girafe()` function to render the plot. The tooltip is set in the aesthetics.

```{r}
library(ggiraph)

gg <- ggplot(iris2, aes(x = Sepal.Length, y = Sepal.Width,  colour = Species, tooltip = Country)) +
  geom_point_interactive()

girafe(ggobj = gg)
```

### Creating detailed graphics with ggpubr

The `ggpubr` package provides wrapper functions for ggplot that make it easier to generate complex, publication ready graphics. It includes functions for running statistical tests and displaying the results in the plot. After using ggpubr, you will need to reset your theme with `theme_set()`.

Don't worry about the details of the code below, this is just to show you some of the possibilities with ggpubr.

```{r, warning=F}
# Violin plots with box plots inside
data("ToothGrowth")
df <- ToothGrowth

my_comparisons <- list( c("0.5", "1"), c("1", "2"), c("0.5", "2") )

ggviolin(df, x = "dose", y = "len", fill = "dose",
         palette = c("#00AFBB", "#E7B800", "#FC4E07"),
         add = "boxplot", add.params = list(fill = "white")) +
  stat_compare_means(comparisons = my_comparisons, label = "p.signif") + # Add significance levels
  stat_compare_means(label.y = 50)                                      # Add p-value 
```

The next example additionally uses the library `cowplot` to add density plots within the margins of the main figure. Don't worry if you get lost here, this is just a demonstration of what's possible in R and beyond the scope of this course.

```{r}
library(cowplot) 
# Main plot
pmain <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  ggpubr::color_palette("jco")
# Marginal densities along x axis
xdens <- axis_canvas(pmain, axis = "x") +
  geom_density(data = iris, aes(x = Sepal.Length, fill = Species),
              alpha = 0.7, linewidth = 0.2)+
  ggpubr::fill_palette("jco")
# Marginal densities along y axis
# Need to set coord_flip = TRUE, if you plan to use coord_flip()
ydens <- axis_canvas(pmain, axis = "y", coord_flip = TRUE)+
  geom_density(data = iris, aes(x = Sepal.Width, fill = Species),
                alpha = 0.7, linewidth = 0.2)+
  coord_flip() +
  ggpubr::fill_palette("jco")
p1 <- insert_xaxis_grob(pmain, xdens, grid::unit(.2, "null"), position = "top")
p2 <- insert_yaxis_grob(p1, ydens, grid::unit(.2, "null"), position = "right")
ggdraw(p2)
```

::: challenge
<h2><i class="fas fa-pencil-alt"></i> Challenge:</h2>

Spend the remaining time playing around with the different ggplot options and see if you can create an interesting and appealing visualisation with a dataset of your choice.\
\
Use these resources for inspiration!

-   [ggplot cheatsheet](https://rstudio.github.io/cheatsheets/html/data-visualization.html)
-   [R graph gallery](https://www.r-graph-gallery.com/index.html)
-   [ggplot extensions](https://exts.ggplot2.tidyverse.org/gallery/)
:::

<br>

::: resources
<h2><i class="fas fa-book"></i> Further Learning</h2>
-   [ggplot2 website](https://ggplot2.tidyverse.org/)
-   [R for Data Science (free online book)](https://r4ds.hadley.nz/)
:::

<br>

::: key-points
<h2><i class="fas fa-thumbtack"></i> Key points</h2>

-   ggplot2 builds graphics layer upon layer
-   Bind a **data** set to your ggplot function and **map** values to visual **aesthetics**
-   Apply different **geometries** to create different graphics
-   Use colours, fills, gradients, shapes etc. to represent **multiple variables**
-   Use **themes* to alter the appearance of a graphic
-   Generate sublots with **faceting**
-   **Save** your graphics with `ggsave`
-   There are many **additional libraries** that extend the functionality of ggplot
:::
