[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science for Biology",
    "section": "",
    "text": "This is the homepage for Data Science for Biology hosted by the DRP-HCB Bioinformatics Core at the University of Edinburgh.\nThese courses are run annually by the Bioinformatics Core but are also available upon request.\n\n\n\n\n\n\n\n\nFor more information contact Shaun Webb."
  },
  {
    "objectID": "02-Programming.html",
    "href": "02-Programming.html",
    "title": "Programming in R",
    "section": "",
    "text": "Understand the power of R as a programming language\nLearn to use control flow statements in R\nLearn how to write your own functions\nWrite and run reproducible R scripts"
  },
  {
    "objectID": "02-Programming.html#programming-in-r",
    "href": "02-Programming.html#programming-in-r",
    "title": "Programming in R",
    "section": "Programming in R",
    "text": "Programming in R\nR is a powerful programming language that allows you to perform complex data analysis tasks.\nOne of the key advantages of using a programming language like R is that it allows you to automate repetitive tasks and publish code that is fully reproducible.\n\nCode can be shared with others, allowing them to reproduce your results\nCode can be reused for different datasets or analyses\nCode can be run in batch mode, allowing you to process large datasets or run multiple analyses at once"
  },
  {
    "objectID": "02-Programming.html#nested-functions",
    "href": "02-Programming.html#nested-functions",
    "title": "Programming in R",
    "section": "Nested functions",
    "text": "Nested functions\nR functions can be nested inside other functions. This allows you to perform multiple operations on data without creating intermediate variables. For example, you can use the mean function inside the log function to calculate the log of the mean of a set of numbers:\n\nlog( mean(c(3,2,4,6,7)) )\n\n[1] 1.481605\n\n\nR will perform the innermost function first, which is the mean function, and then pass the result to the log function.\nWe can also use nested functions to perform more complex operations. For example, we can use the subset function to filter the cars dataset for rows where the speed is greater than 10, and then use the head function to display the first 3 rows of the filtered dataset:\n\nhead( subset(cars, speed &gt; 10), n = 3)\n\n   speed dist\n10    11   17\n11    11   28\n12    12   14\n\n\nNested functions are very powerful but can make your code difficult to understand if you nest many functions together. Later on we will learn how to use the R pipe operator |&gt; to combine functions in a more naturual way."
  },
  {
    "objectID": "02-Programming.html#control-flow-statements",
    "href": "02-Programming.html#control-flow-statements",
    "title": "Programming in R",
    "section": "Control flow statements",
    "text": "Control flow statements\nLet’s begin by looking at some of the basic programming concepts in R. Control flow statements allow you to control the flow of your code based on certain conditions. These are essential for writing complex and dynamic code and common to most programming languages.\n\nIf statements\nIf statements allow you to execute a block of code only if a certain condition is true. For example:\n\nx &lt;- 5\nif (x &gt; 3) {\n  print(\"x is greater than 3\")\n}\n\n[1] \"x is greater than 3\"\n\n\nIf statements can also include an else clause, which allows you to execute a block of code if the condition is false:\n\nx &lt;- 2\nif (x &gt; 3) {\n  print(\"x is greater than 3\")\n} else {\n  print(\"x is not greater than 3\")\n}\n\n[1] \"x is not greater than 3\"\n\n\nIf statements can also be nested, allowing you to check multiple conditions:\n\nx &lt;- 5\nif (x &gt; 3) {\n  print(\"x is greater than 3\")\n  if (x &lt; 10) { ## This if statement only runs if the first condition is true\n    print(\"x is also less than 10\")\n  }\n} else {\n  print(\"x is not greater than 3\")\n}\n\n[1] \"x is greater than 3\"\n[1] \"x is also less than 10\"\n\n\nIf statements can also be combined with logical operators to check multiple conditions at once:\n\nx &lt;- 5\nif (x &gt; 3 && x &lt; 10) {\n  print(\"x is greater than 3 and less than 10\")\n}\n\n[1] \"x is greater than 3 and less than 10\"\n\n\n\nOther logical operators in R\n\n&& - and\n|| - or\n! - not\n== - equal to\n!= - not equal to\n&gt; - greater than\n&lt; - less than\n&gt;= - greater than or equal to\n&lt;= - less than or equal to\n\n\nx &lt;- 5\ny &lt;- 10\nif (x &gt;= 5 && y != 15) {\n  print(\"x is greater than or equal to 5 and y is not equal to 15\")\n}\n\n[1] \"x is greater than or equal to 5 and y is not equal to 15\"\n\n\nIf statements and logic operators can be used with character strings.\n\nx &lt;- \"banana\"\nif (x == \"apple\") {\n  print(\"x is an apple\")\n} else {\n  print(paste(x, \"is not an apple\"))\n}\n\n[1] \"banana is not an apple\"\n\n\nYou can use else if to check multiple conditions in sequence.\n\nx &lt;- \"pear\"\nif (x == \"apple\") {\n  print(\"x is an apple\")\n} else if (x == \"banana\") {\n  print(\"x is a banana\")\n} else {\n  print(paste(x, \"is not an apple or a banana\"))\n}\n\n[1] \"pear is not an apple or a banana\"\n\n\nThe next example has a logical value called draw_plot that is set to FALSE by default. The if statement checks if there are at least 5 data points in the cars dataset after filtering for rows with a speed less than limit. If there are, it sets draw_plot to TRUE and plots the data.\n\n## Only plot data if there are at least 5 data points\nlimit = 20\ndraw_plot = FALSE # Set plot to FALSE by default\ncars_filtered &lt;- subset(cars,cars$speed &lt; limit)\n\nif (nrow(cars_filtered) &gt;= 5) {\n  draw_plot &lt;- TRUE\n}\n\nif (draw_plot == TRUE) {\n  plot(cars)\n}\n\n\n\n\n\n\n\n\nTry setting limit to 7 and rerun the code. What happens?\nIf statements can also be used on vectors or data frames. For example, you can use an if statement to check if a certain value is present in a vector:\n\nx &lt;- c(1, 2, 3, 4, 5)\nif (3 %in% x) {\n  print(\"3 is in the vector x\")\n}\n\n[1] \"3 is in the vector x\"\n\n\nThe %in% is a special operator in R that is used to check if a value is present in a vector or data frame. It returns a logical value indicating if there is a match or not.\n\n\n Challenge:\n\nWrite an if statement to determine if a treatment has a significant effect on gene expression based on a t-test result.\nUse the following code to perform the t-test:\n\n# Sample data frame of gene expression values\nqpcr_example &lt;- data.frame(\n  Condition = c(rep(\"Control\", 5), rep(\"Treatment\", 5)),\n  delta_ct = c(2, 3, 1, 4, 2, 1, 2, 0, 3, 3)\n)\n\n# Perform t-test\nqpcr_result &lt;- t.test(delta_ct ~ Condition, data = qpcr_example, var.equal=TRUE)\n\nPlot a boxplot of the delta_ct values for the control and treatment groups. Add a title to the plot indicating whether the treatment has a significant effect on gene expression based on the t-test result.\nSee if you can add the p-value as a subtitle.\nHINTS\n\nA title can be added with the main argument in the boxplot function.\nYou can use an if statement to determine the title based on the p-value from the t-test result.\nStore the title text in an object and use that object in the main argument of the boxplot function.\nThe p-value can be accessed from the t-test result object with qpcr_result$p.value.\nThe subtitle can be added with the sub argument in the boxplot function.\n\n\n\n\n\nSolution. \n\n Solution:\n\n\n# Check the p-value from the t-test result\nif (qpcr_result$p.value &lt;= 0.05) {\n  title &lt;- \"The treatment has a significant effect on gene expression.\"\n} else {\n  title &lt;- \"The treatment does not have a significant effect on gene expression.\"\n}\n# Plot the boxplot\nboxplot(delta_ct ~ Condition, data = qpcr_example, main = title, sub = paste(\"p-value:\", round(qpcr_result$p.value, 4)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor loops\nFor loops allow you to repeat a block of code a certain number of times. For example, you can use a for loop to iterate over a vector of values:\n\n## Every time the loop runs, the variable i takes on the next value in the sequence from 1 to 5\nfor (i in 1:5) {\n  print(i+1)\n}\n\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n\n\nFor loops can also be used to iterate over the rows of a data frame:\n\n# Create a data frame of human patients and their ages\n\ndf &lt;- data.frame(\n  patient = c(\"Eve\", \"Arnold\", \"Fred\"),\n  age = c(10, 30, 35)\n)\ndf\n\n  patient age\n1     Eve  10\n2  Arnold  30\n3    Fred  35\n\n\nWe can use a for loop to iterate over the rows of the data frame and print out a message for each patient:\n\n# Use a for loop to iterate over the rows of the data frame\nfor (i in 1:nrow(df)) {\n  \n  # Use an if statement to classify patients as \"Child\" or \"Adult\" based on their age\n  if (df$age[i] &lt; 18) {\n     classification &lt;- \"Child\"\n  } else{\n     classification &lt;- \"Adult\"\n  }\n  \n  ## Print a statement for each patient\n  print(paste(df$patient[i], \"is visiting the doctor and is classified as\", classification))\n\n}\n\n[1] \"Eve is visiting the doctor and is classified as Child\"\n[1] \"Arnold is visiting the doctor and is classified as Adult\"\n[1] \"Fred is visiting the doctor and is classified as Adult\"\n\n\n\n\n Challenge:\n\nWrite code with control flow that takes a data frame of gene expression values and creates a new column expression classified as “low”, “medium”, or “high” based on the following criteria:\n\nlow if the expression value is less than 10\nmedium if the expression value is between 10 and 100\nhigh if the expression value is greater than 100\n\n\n# Create a sample data frame of gene expression values\ngene_expression &lt;- data.frame(\n  gene = c(\"gene1\", \"gene2\", \"gene3\", \"gene4\", \"gene5\"),\n  expression_value = c(5, 15, 50, 150, 200)\n)\n\n# Create a new column to store the classifications, set to NA by default\ngene_expression$expression &lt;- NA\n\nHINTS\n\nYou can use a for loop to iterate over the rows of the data frame\nUse if else if and else statements to classify the expression values based on the criteria provided.\n\n\n\n\n\nSolution. \n\n Solution:\n\n\n## loop through the rows\nfor (i in 1:nrow(gene_expression)) {\n  \n  ## Check the expression level and assign with if statements\n  if (gene_expression$expression_value[i] &lt; 10) {\n    gene_expression$expression[i] &lt;- \"low\"\n  } else if (gene_expression$expression_value[i] &gt;= 10 && gene_expression$expression_value[i] &lt;= 100) {\n    gene_expression$expression[i] &lt;- \"medium\"\n  } else {\n    gene_expression$expression[i] &lt;- \"high\"\n  }\n\n}\n\n# View the resulting data frame\nprint(gene_expression)\n\n   gene expression_value expression\n1 gene1                5        low\n2 gene2               15     medium\n3 gene3               50     medium\n4 gene4              150       high\n5 gene5              200       high\n\n\n\n\n\n\nFor loops and if statements are used in almost every programming language. They allow you to write code that can adapt to different situations and perform complex tasks.\nHowever, they can be slow to run on large datasets and there are more efficient ways to manipulate data frames in R. We will cover some of these in later modules."
  },
  {
    "objectID": "02-Programming.html#writing-functions",
    "href": "02-Programming.html#writing-functions",
    "title": "Programming in R",
    "section": "Writing functions",
    "text": "Writing functions\nFunctions are reusable blocks of code that perform a specific task. They allow you to break down complex problems into smaller, more manageable pieces.\nYou have already used many functions in R, such as plot(), read.table(), and t.test(). All of these functions have underlying code that performs a specific task when you call the function. In fact, you can print the code for any function in R by simply typing the name of the function without parentheses.\nTry this with the read.table function:\n\nread.table\n\nfunction (file, header = FALSE, sep = \"\", quote = \"\\\"'\", dec = \".\", \n    numerals = c(\"allow.loss\", \"warn.loss\", \"no.loss\"), row.names, \n    col.names, as.is = !stringsAsFactors, tryLogical = TRUE, \n    na.strings = \"NA\", colClasses = NA, nrows = -1, skip = 0, \n    check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, \n    blank.lines.skip = TRUE, comment.char = \"#\", allowEscapes = FALSE, \n    flush = FALSE, stringsAsFactors = FALSE, fileEncoding = \"\", \n    encoding = \"unknown\", text, skipNul = FALSE) \n{\n    if (missing(file) && !missing(text)) {\n        file &lt;- textConnection(text, encoding = \"UTF-8\")\n        encoding &lt;- \"UTF-8\"\n        on.exit(close(file))\n    }\n    if (is.character(file)) {\n        file &lt;- if (nzchar(fileEncoding)) \n            file(file, \"rt\", encoding = fileEncoding)\n        else file(file, \"rt\")\n        on.exit(close(file))\n    }\n    if (!inherits(file, \"connection\")) \n        stop(\"'file' must be a character string or connection\")\n    if (!isOpen(file, \"rt\")) {\n        open(file, \"rt\")\n        on.exit(close(file))\n    }\n    pbEncoding &lt;- if (encoding %in% c(\"\", \"bytes\", \"UTF-8\")) \n        encoding\n    else \"bytes\"\n    numerals &lt;- match.arg(numerals)\n    if (skip &gt; 0L) \n        readLines(file, skip)\n    nlines &lt;- n0lines &lt;- if (nrows &lt; 0L) \n        5\n    else min(5L, (header + nrows))\n    lines &lt;- .External(C_readtablehead, file, nlines, comment.char, \n        blank.lines.skip, quote, sep, skipNul)\n    if (encoding %in% c(\"UTF-8\", \"latin1\")) \n        Encoding(lines) &lt;- encoding\n    nlines &lt;- length(lines)\n    if (!nlines) {\n        if (missing(col.names)) \n            stop(\"no lines available in input\")\n        rlabp &lt;- FALSE\n        cols &lt;- length(col.names)\n    }\n    else {\n        if (all(!nzchar(lines))) \n            stop(\"empty beginning of file\")\n        if (nlines &lt; n0lines && file == 0L) {\n            pushBack(c(lines, lines, \"\"), file, encoding = pbEncoding)\n            on.exit((clearPushBack(stdin())))\n        }\n        else pushBack(c(lines, lines), file, encoding = pbEncoding)\n        first &lt;- scan(file, what = \"\", sep = sep, quote = quote, \n            nlines = 1, quiet = TRUE, skip = 0, strip.white = TRUE, \n            blank.lines.skip = blank.lines.skip, na.strings = character(0), \n            comment.char = comment.char, allowEscapes = allowEscapes, \n            encoding = encoding, skipNul = skipNul)\n        col1 &lt;- if (missing(col.names)) \n            length(first)\n        else length(col.names)\n        col &lt;- numeric(nlines - 1L)\n        if (nlines &gt; 1L) \n            for (i in seq_along(col)) col[i] &lt;- length(scan(file, \n                what = \"\", sep = sep, quote = quote, nlines = 1, \n                quiet = TRUE, skip = 0, strip.white = strip.white, \n                blank.lines.skip = blank.lines.skip, comment.char = comment.char, \n                allowEscapes = allowEscapes, encoding = encoding, \n                skipNul = skipNul))\n        cols &lt;- max(col1, col)\n        rlabp &lt;- (cols - col1) == 1L\n        if (rlabp && missing(header)) \n            header &lt;- TRUE\n        if (!header) \n            rlabp &lt;- FALSE\n        if (header) {\n            .External(C_readtablehead, file, 1L, comment.char, \n                blank.lines.skip, quote, sep, skipNul)\n            if (missing(col.names)) \n                col.names &lt;- first\n            else if (length(first) != length(col.names)) \n                warning(\"header and 'col.names' are of different lengths\")\n        }\n        else if (missing(col.names)) \n            col.names &lt;- paste0(\"V\", 1L:cols)\n        if (length(col.names) + rlabp &lt; cols) \n            stop(\"more columns than column names\")\n        if (fill && length(col.names) &gt; cols) \n            cols &lt;- length(col.names)\n        if (!fill && cols &gt; 0L && length(col.names) &gt; cols) \n            stop(\"more column names than columns\")\n        if (cols == 0L) \n            stop(\"first five rows are empty: giving up\")\n    }\n    if (check.names) \n        col.names &lt;- make.names(col.names, unique = TRUE)\n    if (rlabp) \n        col.names &lt;- c(\"row.names\", col.names)\n    nmColClasses &lt;- names(colClasses)\n    if (is.null(nmColClasses)) {\n        if (length(colClasses) &lt; cols) \n            colClasses &lt;- rep_len(colClasses, cols)\n    }\n    else {\n        tmp &lt;- rep_len(NA_character_, cols)\n        names(tmp) &lt;- col.names\n        i &lt;- match(nmColClasses, col.names, 0L)\n        if (any(i &lt;= 0L)) \n            warning(\"not all columns named in 'colClasses' exist\")\n        tmp[i[i &gt; 0L]] &lt;- colClasses[i &gt; 0L]\n        colClasses &lt;- tmp\n    }\n    what &lt;- rep.int(list(\"\"), cols)\n    names(what) &lt;- col.names\n    colClasses[colClasses %in% c(\"real\", \"double\")] &lt;- \"numeric\"\n    known &lt;- colClasses %in% c(\"logical\", \"integer\", \"numeric\", \n        \"complex\", \"character\", \"raw\")\n    what[known] &lt;- lapply(colClasses[known], do.call, list(0))\n    what[colClasses %in% \"NULL\"] &lt;- list(NULL)\n    keep &lt;- !vapply(what, is.null, NA)\n    data &lt;- scan(file = file, what = what, sep = sep, quote = quote, \n        dec = dec, nmax = nrows, skip = 0, na.strings = na.strings, \n        quiet = TRUE, fill = fill, strip.white = strip.white, \n        blank.lines.skip = blank.lines.skip, multi.line = FALSE, \n        comment.char = comment.char, allowEscapes = allowEscapes, \n        flush = flush, encoding = encoding, skipNul = skipNul)\n    nlines &lt;- length(data[[which.max(keep)]])\n    if (cols != length(data)) {\n        warning(\"cols = \", cols, \" != length(data) = \", length(data), \n            domain = NA)\n        cols &lt;- length(data)\n    }\n    if (is.logical(as.is)) {\n        as.is &lt;- rep_len(as.is, cols)\n    }\n    else if (is.numeric(as.is)) {\n        if (any(as.is &lt; 1 | as.is &gt; cols)) \n            stop(\"invalid numeric 'as.is' expression\")\n        i &lt;- rep.int(FALSE, cols)\n        i[as.is] &lt;- TRUE\n        as.is &lt;- i\n    }\n    else if (is.character(as.is)) {\n        i &lt;- match(as.is, col.names, 0L)\n        if (any(i &lt;= 0L)) \n            warning(\"not all columns named in 'as.is' exist\")\n        i &lt;- i[i &gt; 0L]\n        as.is &lt;- rep.int(FALSE, cols)\n        as.is[i] &lt;- TRUE\n    }\n    else if (length(as.is) != cols) \n        stop(gettextf(\"'as.is' has the wrong length %d  != cols = %d\", \n            length(as.is), cols), domain = NA)\n    do &lt;- keep & !known\n    if (rlabp) \n        do[1L] &lt;- FALSE\n    for (i in (1L:cols)[do]) {\n        data[[i]] &lt;- if (is.na(colClasses[i])) \n            type.convert(data[[i]], as.is = as.is[i], dec = dec, \n                numerals = numerals, na.strings = character(0L), \n                tryLogical = tryLogical)\n        else if (colClasses[i] == \"factor\") \n            as.factor(data[[i]])\n        else if (colClasses[i] == \"Date\") \n            as.Date(data[[i]])\n        else if (colClasses[i] == \"POSIXct\") \n            as.POSIXct(data[[i]])\n        else methods::as(data[[i]], colClasses[i])\n    }\n    compactRN &lt;- TRUE\n    if (missing(row.names)) {\n        if (rlabp) {\n            row.names &lt;- data[[1L]]\n            data &lt;- data[-1L]\n            keep &lt;- keep[-1L]\n            compactRN &lt;- FALSE\n        }\n        else row.names &lt;- .set_row_names(as.integer(nlines))\n    }\n    else if (is.null(row.names)) {\n        row.names &lt;- .set_row_names(as.integer(nlines))\n    }\n    else if (is.character(row.names)) {\n        compactRN &lt;- FALSE\n        if (length(row.names) == 1L) {\n            rowvar &lt;- (1L:cols)[match(col.names, row.names, 0L) == \n                1L]\n            row.names &lt;- data[[rowvar]]\n            data &lt;- data[-rowvar]\n            keep &lt;- keep[-rowvar]\n        }\n    }\n    else if (is.numeric(row.names) && length(row.names) == 1L) {\n        compactRN &lt;- FALSE\n        rlabp &lt;- row.names\n        row.names &lt;- data[[rlabp]]\n        data &lt;- data[-rlabp]\n        keep &lt;- keep[-rlabp]\n    }\n    else stop(\"invalid 'row.names' specification\")\n    data &lt;- data[keep]\n    if (is.object(row.names) || !(is.integer(row.names))) \n        row.names &lt;- as.character(row.names)\n    if (!compactRN) {\n        if (length(row.names) != nlines) \n            stop(\"invalid 'row.names' length\")\n        if (anyDuplicated(row.names)) \n            stop(\"duplicate 'row.names' are not allowed\")\n        if (anyNA(row.names)) \n            stop(\"missing values in 'row.names' are not allowed\")\n    }\n    class(data) &lt;- \"data.frame\"\n    attr(data, \"row.names\") &lt;- row.names\n    data\n}\n&lt;bytecode: 0x107a616b0&gt;\n&lt;environment: namespace:utils&gt;\n\n\nTo start with, the code is quite long. This should really highlight the power of functions in R. Instead of having to write all of this code every time you want to read in a table, you can simply call the read.table function and it will execute all of that code for you.\nIf you scroll to the beginning, you can see that the code begins with a call of function, which indicates that this is a function definition. This is followed by the arguments that the function takes, which are listed in parentheses (). In this case, the read.table function takes several arguments, such as file, header, and sep.\nThe code inside the curly braces {} is the body of the function, which contains the code and control flow statements that will be executed when the function is called.\n\nCustom functions\nR allows you to create your own custom functions using the same syntax. To create a function in R, you use the function keyword. For example, here is a simple function that takes two numbers as input, calculates the sum and outputs a log transformation:\n\nlog_sum &lt;- function(x, y) {\n  sum &lt;- sum(x,y)\n  logsum &lt;- log(sum)\n  return(logsum)\n}\n\nIn this example, we define a function called log_sum that takes two arguments, x and y. The body of the function calculates the sum of x and y and then transforms it using the log function.\nThe return() function is used to return the value of logsum when the function is called. If a return statement is not included, the function will just return the value of the last expression.\nYou can call this function by passing two numbers as arguments:\n\nlog_sum(3, 5)\n\n[1] 2.079442\n\n\nIf we need to perform this calculation multiple times with different numbers, we can simply call the log_sum function with different arguments instead of writing the same code over and over again.\nWe can add default values to the function arguments. This allows us to call the function without providing values for those arguments, and the default values will be used instead. For example:\n\nlog_sum &lt;- function(x, y, base = exp(1)) {\n  sum &lt;- sum(x,y)\n  logsum &lt;- log(sum, base = base)\n  return(logsum)\n}\n\nIn this example, we added a new argument called base with a default value of exp(1), which is the natural logarithm base. If we call the function without providing a value for base, it will use the default value:\n\nlog_sum(3, 5)\n\n[1] 2.079442\n\n\nIf we want to use a different base for the logarithm, we can provide a value for the base argument when calling the function:\n\nlog_sum(3, 5, base = 10)\n\n[1] 0.90309\n\n\nAnother useful feature of functions in R is that they can return multiple values as a list. For example:\n\nlog_sum &lt;- function(x, y, base = exp(1)) {\n  sum &lt;- x + y\n  logsum &lt;- log(sum, base = base)\n  return(list(sum = sum, logsum = logsum))\n}\n\nIn this example, the log_sum function returns a list containing both the sum and the log of the sum. You can access these values using the $ operator:\n\nresult &lt;- log_sum(3, 5)\nresult$sum\n\n[1] 8\n\nresult$logsum\n\n[1] 2.079442\n\n\nFunctions are a fundamental part of programming in R. They allow you to write reusable code that can be easily maintained and shared with others. They also help to make your code more organised and easier to read.\n\n\n Challenge:\n\nWrite a function called qPCR_analysis that performs all of the steps we used in the first session.\n\nLoad the data from “data/qpcr_results.xlsx” into a data frame.\nCalculate the delta_ct values for each sample.\nPerform a t-test to compare the delta_ct values between the two conditions.\nCalculate the fold change in gene expression between the treatment and control groups.\nPlot a boxplot of the delta_ct values for the control and treatment groups.\n\nThe function should take a data frame as an argument and return a list containing the t-test result and the fold change. It should also plot a boxplot of delta_ct values per condition.\n\n\n\n\nSolution. \n\n Solution:\n\n\nqPCR_analysis &lt;- function(qpcr_table) {\n  \n  # Calculate delta_ct values\n  qpcr_table$delta_ct &lt;- qpcr_table$ct_gene - qpcr_table$ct_ref\n  \n  # Plot boxplot in base R\n  boxplot(delta_ct ~ Condition, data = qpcr_table, main = \"Delta Ct values by condition\", ylab = \"Delta Ct\")\n  \n  # Perform t-test\n  t_test_result &lt;- t.test(delta_ct ~ Condition, data = qpcr_table, var.equal=TRUE)\n  \n  # Calculate fold change\n  mean_control &lt;- mean(qpcr_table$delta_ct[qpcr_table$Condition == \"Control\"])\n  mean_treatment &lt;- mean(qpcr_table$delta_ct[qpcr_table$Condition == \"Treatment\"])\n  delta_delta_ct &lt;- mean_treatment - mean_control\n  fold_change &lt;- 2^(-delta_delta_ct)\n  \n  return(list(t_test_result = t_test_result, fold_change = fold_change, boxplot = boxplot))\n}\n\n\n\n\n\nYou can call this function by passing a data frame containing the qPCR results:\n\n# Load the data\nlibrary(readxl)\nqpcr_result &lt;- read_excel(\"data/qpcr_data.xlsx\")\n\n# Call the qPCR_analysis function\nresults &lt;- qPCR_analysis(qpcr_result)\n\n\n\n\n\n\n\n# Access the p-value and fold change\npaste(\"The p-value is \", results$t_test_result$p.value, \" and the fold change is \", results$fold_change)\n\n[1] \"The p-value is  1.82070315127758e-08  and the fold change is  2.953652291879\"\n\n\nWe have now written a function that performs all of the steps of our qPCR analysis. This function can be reused for different datasets by simply passing a different data frame as an argument.\nLet’s load a second qPCR dataset to test our function:\n\n# Download the second dataset\ndownload.file(\"http://bifx-core3.bio.ed.ac.uk/training/DSB/data/qPCR_data2.xlsx\", destfile = \"data/qpcr_data2.xlsx\")\n\nlibrary(readxl)\nqpcr_table2 &lt;- read_excel(\"data/qpcr_data2.xlsx\")\n\n# Call the qPCR_analysis function\nresults2 &lt;- qPCR_analysis(qpcr_table2)\n\n\n\n\n\n\n\npaste(\"The p-value is \", results2$t_test_result$p.value, \" and the fold change is \", results2$fold_change)\n\n[1] \"The p-value is  0.207646591718013  and the fold change is  0.726986258660155\"\n\n\nHow easy was that! This is the power of functions in R."
  },
  {
    "objectID": "02-Programming.html#reproducible-r-scripts",
    "href": "02-Programming.html#reproducible-r-scripts",
    "title": "Programming in R",
    "section": "Reproducible R scripts",
    "text": "Reproducible R scripts\nR scripts are plain text files that contain R code. They can be created and edited in any text editor, but using an environment like RStudio makes it easier to write and run your code.\nSaving your code in an R script allows you to keep a record of your analysis and makes it easier to reproduce your results. You can also share your R scripts with others, allowing them to run the same code on different data.\n\nRunning R scripts\nR scripts can be run interactively in RStudio by clicking the “Source” button or by using the source() function in the console. For example, if you have an R script called analysis.R in your working directory, you can run it with the following command:\n\n## Example, don't run this\nsource(\"analysis.R\")\n\nR scripts can also be run from the Windows, Mac or Linux command line. This is useful for several reasons:\n\nRun R scripts without opening RStudio\nRun R scripts with arguments (see below)\nInclude R scripts in larger workflows or pipelines\nRun R scripts on a remote server or cluster\nRun multiple R analyses at once\n\nTo run an R script from the command line, you need to open a Terminal window. Most computers have a Terminal app installed. RStudio has an inbuilt Terminal, you can find it next to the Console tab.\n\nConsole is where you can run R commands interactively.\nTerminal is where you can run command line commands on your computer or server.\n\nTo run an R script on the command line, use the Rscript command:\n\n## Example, don't run this \nRscript analysis.R\n\n\n\nExample R Script\nDownload the R script below and open it in RStudio for reading.\n\ndir.create(\"scripts\")\ndownload.file(\"http://bifx-core3.bio.ed.ac.uk/training/DSB/scripts/qPCR_analysis.R\", destfile = \"scripts/qpcr_analysis.R\")\n\n\n\n Discussion:\n\n\nWhat does the script do?\nWhat are the inputs and outputs of the script?\nWhere are the output files saved?\nWhat are the advantages of using an R script instead of running code interactively in the console?\n\n\n\nTry running this script in RStudio and from the command line. Make sure you are in your working directory.\n\nRscript scripts/qpcr_analysis.R\n\n\nWhat happens when you run the R Script?\nWhere does the output appear?\n\n\n\nArguments\nAt the moment our script is not very flexible. It is hard coded to read in a specific file and save the output to a specific location.\nWe can make our script more flexible by using arguments. Arguments allow us to specify the input and output files on the command line instead of in the script. This way, we can change them easily without ever having to edit the code e.g.\n\n## These are just examples, don't run them yet.\nRscript qPCR_analysis.R data/qpcr_results.xlsx qpcr_plot_exp1.png\n\nOR\n\nRscript qPCR_analysis.R data/qpcr_results2.xlsx qpcr_plot_exp2.png\n\nR interprets everything after the script name as an argument to the script. In the example above, data/qpcr_results.xlsx is the input file containing the qPCR results and qpcr_plot.png is the name of the output file where the plot will be saved.\nWe need to make a few changes to our script for R to accept these argument. We can use the built-in function commandArgs() to access the arguments passed to the script from the command line. You can use this function to read in the input and output file paths as arguments. For example:\n\nargs &lt;- commandArgs(trailingOnly = TRUE) ## trailingOnly = TRUE means that only the arguments after the script name will be returned\ninput_file &lt;- args[1] # The first argument will be the input file path\noutput_file &lt;- args[2] # The second argument will be the output file path\n\nThis code will read in the first and second arguments passed to the script and store them in the input_file and output_file variables, respectively. You can then use these variables in your code to read in the data and save the plot.\n\n\n Challenge:\n\nModify the qPCR_analysis.R script to use the input and output file paths as arguments.\nHINTS\n\nUse the commandArgs() function to read in the arguments from the command line.\nReplace the hardcoded input file name with the input_file variable.\nReplace the hardcoded output file name with the output_file variable to save the plot.\n\n\n\n\n\nSolution. \n\n Solution:\n\n\nlibrary(readxl)\n\nargs &lt;- commandArgs(trailingOnly = TRUE) ## trailingOnly = TRUE means that only the arguments after the script name will be returned\ninput_file &lt;- args[1]\noutput_file &lt;- args[2]\n\n# Read in the data\nqpcr_data &lt;- read_excel(input_file)\n\n# Function to perform qPCR analysis\nqPCR_analysis &lt;- function(qpcr_table,plot_file) {\n  \n  # Calculate delta_ct values\n  qpcr_table$delta_ct &lt;- qpcr_table$ct_gene - qpcr_table$ct_ref\n  \n  # Perform t-test\n  t_test_result &lt;- t.test(delta_ct ~ Condition, data = qpcr_table, var.equal=TRUE)\n  \n  # Calculate fold change\n  mean_control &lt;- mean(qpcr_table$delta_ct[qpcr_table$Condition == \"Control\"])\n  mean_treatment &lt;- mean(qpcr_table$delta_ct[qpcr_table$Condition == \"Treatment\"])\n  delta_delta_ct &lt;- mean_treatment - mean_control\n  fold_change &lt;- 2^(-delta_delta_ct)\n  \n  # Save boxplot as a PDF\n  png(plot_file)\n  boxplot(delta_ct ~ Condition, \n          data = qpcr_table, \n          main = \"Delta Ct values by condition\", \n          ylab = \"Delta Ct\",\n          sub = paste(\"Fold change:\", round(fold_change, 2), \n                      \"p-value:\", round(t_test_result$p.value, 4))\n          )\n  dev.off()\n}\n\nqPCR_analysis(qpcr_data, output_file)\n\n\n\n\n\nTry running the modified script from the terminal window specifying the input and output file names:\n\nRscript scripts/qPCR_analysis.R data/qpcr_data.xlsx qPCR_plot_exp1.png\n\nNow run the script on our second qPCR dataset:\n\nRscript scripts/qPCR_analysis.R data/qpcr_data2.xlsx qPCR_plot_exp2.png\n\n\n\nCommenting and formatting\nWhen writing R scripts, it’s important to use good commenting and formatting practices. This makes your code easier to read and understand, both for yourself and for others who may be reading your code in the future.\nSome quick tips:\n\nUse comments to explain what your code is doing and why. This is especially important for complex code or code that may not be immediately obvious.\nUse consistent indentation and spacing to make your code more readable. This can help to visually separate different blocks of code and make it easier to follow the flow of the script.\nUse meaningful variable names that describe the purpose of the variable.\nBreak up long lines of code into multiple lines to improve readability. This can help to prevent horizontal scrolling and make it easier to read the code.\nUse functions to break up your code into smaller, more manageable pieces.\n\nLater on we will cover some tools that can help with formatting your code, such as the styler package and the formatR package.\n\n\n Challenge:\n\nSee if you can add more customisable arguments to the qPCR_analysis.R script. Be sure to comment your edits and use good formatting practices.\nSOME IDEAS\n\nAllow the user to specify the title of the plot as an argument.\nAllow the user to specify the plot file format to be either png or pdf as an argument (hint: use an if statement)."
  },
  {
    "objectID": "02-Programming.html#summary",
    "href": "02-Programming.html#summary",
    "title": "Programming in R",
    "section": "Summary",
    "text": "Summary\nUsing scripts and programmable functions is a really powerful way to perform your data analysis. Programming languages provide automation, flexibility and reproducibility.\n\n\n Resources\n\n\nThe Discdown R Programming book is a comprehensive resource introducing R datatypes, syntax and programming concepts. It is available online for free.\n\n\n\n\n\n Key points\n\n\nR is a powerful programming language that allows you to automate tasks and write reproducible code.\nControl flow functions like if statements and for loops allow you to write code that can adapt to different situations and perform complex tasks.\nFunctions are reusable blocks of code that perform a specific task.\nR scripts allow you to save and share your code, making analyses reproducible and customisable."
  },
  {
    "objectID": "02-HW.html",
    "href": "02-HW.html",
    "title": "Homework Task",
    "section": "",
    "text": "Write an R script to perform a data analysis task"
  },
  {
    "objectID": "02-HW.html#task",
    "href": "02-HW.html#task",
    "title": "Homework Task",
    "section": "Task",
    "text": "Task\nWrite an R script to perform a data analysis task. Your script should do the following:\n\nImport a dataset as a data frame\nPerform exploratory data analysis\n\nSummarise the dataset\nCalculate summary statistics of variables (e.g. mean)\n\nPlot the data (e.g. scatter plot, histogram, boxplot)\nSave the plot to a PNG file\n\nAdditionally, you could try to:\n\nRun a statistical test on the data\nWrite a custom function to use in your script e.g.\n\nTo calculate a specific statistic\nTo perform a specific data manipulation task\nTo create a specific type of plot\n\nParameterise your script by adding command line arguments\n\nIf you need help with this task:\n\nEmail the Bioinformatics Core team, we’re happy to help!\nCome to a drop in session. We run these monthly.\nSearch online, there is an abundance of R forums, guides and videos\nUse AI. It’s pretty good at coding and can be a great way to learn. Just make sure you understand the code it generates and don’t just copy and paste without thinking about it!"
  },
  {
    "objectID": "02-HW.html#data",
    "href": "02-HW.html#data",
    "title": "Homework Task",
    "section": "Data",
    "text": "Data\nYou can use any dataset you like for this task. It would be best to use your own research data if possible. Building your programming skills around your own data is a great way to learn R. Real world data can also be messy and this will give you a more realistic experience of data analysis.\nIf you don’t have your own data, you can use the case study below, find a dataset online or even simulate your own dataset.\n\nPublished data\nYou could use a dataset from a published paper. This is a great way to practice analysing real data interpreting scientific results. You can usually find datasets in the supplementary materials of papers.\nAlternatively, you can use a dataset related to a specfic hobby or interest you might have. Choose something that motivates you!\nKaggle has an abundance of public datasets that you can use for this task at https://www.kaggle.com/datasets e.g.\n\nPremier league football\nCOVID-19 case outcomes\nMovie ratings and revenues\nCensus data\n\n\n\nSimulated data\nThe code below shows how to simulate a fairly generic dataset in R. You could modify the conditions and values to look like a more familiar dataset for your research e.g\n\nGene expression levels across different conditions\nCell counts across different time points\nFluorescence intensity measurements across different samples\n\n\nset.seed(123) # for reproducibility\nn &lt;- 100\n\nsim_data &lt;- data.frame(\n  Condition = c(rep(\"Control\",n/2), rep(\"Treatment\",n/2)),\n  Value = c(rnorm(n/2, mean = 50, sd = 10),rnorm(n/2, mean = 60, sd = 10))\n)"
  },
  {
    "objectID": "02-HW.html#case-study-enhancing-memory-with-neurotrophic-factors",
    "href": "02-HW.html#case-study-enhancing-memory-with-neurotrophic-factors",
    "title": "Homework Task",
    "section": "Case Study: Enhancing Memory with Neurotrophic Factors",
    "text": "Case Study: Enhancing Memory with Neurotrophic Factors\nIn the study of learning and memory, researchers focus on how neurons strengthen their connections, a process called Long-Term Potentiation (LTP). A key player in this process is BDNF (Brain-Derived Neurotrophic Factor), a protein that acts like “fertilizer” for neurons, promoting the growth of dendritic spines, the tiny protrusions on neurons where synapses are formed. More spines generally correlate with a higher capacity for memory storage.\nResearchers are investigating whether a synthetic mimetic of BDNF (called “NeuroBoost”) increases the density of dendritic spines.\n\nExperimental setup:\n\n16 samples (primary neuronal cultures)\n\n8 Control\n8 Treated with NeuroBoost\n\n\nUsing a confocal microscope, a researcher selects a dendrite and counts the number of spines per 10 micrometers (\\(\\mu m\\)) of length. There are 16 independent batches of neurons derived from different embryos. For each batch, the researcher images 3 different neurons to account for the fact that some neurons in a dish are naturally more “branchy” than others.\nThe dataset can be downloaded from here: https://bifx-core3.bio.ed.ac.uk/training/DSB/data/spine_data.csv\n\nhead(spine_data)\n\n  Batch_ID Treatment Neuron_1 Neuron_2 Neuron_3\n1  Batch_1   Control        6        7        7\n2  Batch_2   Control        7        2        7\n3  Batch_3   Control        2        6        8\n4  Batch_4   Control        5        7        5\n5  Batch_5   Control        7        3        7\n6  Batch_6   Control        5        7        7\n\n\nThere are 3 neurons per batch. The neurons within a batch are not biologically independent because they come from the same dish and are influenced by the same microenvironment. Therefore, you cannot treat each neuron as an independent sample. Instead, you should average the 3 neurons to get a single value for each batch, which represents one independent measurement of spine density for that batch. The 16 batches of neurons are the independent samples in this experiment.\n\n\n Hints\n\n\nWhat file format is the data in? Which function will you use to import the data?\nLook into the rowMeans() function to calculate the average spine density for each batch.\nUse a t-test to compare the mean spine density between the Control and NeuroBoost groups.\nCreate a boxplot to visualize the distribution of spine densities for each treatment group."
  },
  {
    "objectID": "01-start.html",
    "href": "01-start.html",
    "title": "Introduction to RStudio",
    "section": "",
    "text": "We recommend using RStudio for this workshop. RStudio is an Integrated Development Environment (IDE) for R. It can be accessed in several ways."
  },
  {
    "objectID": "01-start.html#using-rstudio",
    "href": "01-start.html#using-rstudio",
    "title": "Introduction to RStudio",
    "section": "Using RStudio",
    "text": "Using RStudio\nA comprehensive RStudio user guide is available here.\n\n\nThe are 4 main panes, each with several tabs:\n\nConsole (bottom left)\n\nHere you can type commands into R\nAdditional tabs may include a terminal and script outputs\n\nSource (top left)\n\nOpen and view files\nThese can be raw txt, scripts or markdown\n\nEnvironments (top right)\n\nObjects you have stored\nCommands you have typed\nAdditional tabs for version control, database and website building…\n\nOutput (bottom right)\n\nSystem files (on the computer/server you are working on)\nOutput from plots or applications\nPackages available\nHelp pages\n\n\n\n\n\n\n\nYou can customise the appearance of RStudio under the menu option: Tools -&gt; Global Options…\n\nSetting up a new project\nThere is a drop-down project menu at the top right of RStudio. Click this, select “New Project…” and create one in a new directory. Make sure you have write permission for the directory you choose.\nOnce you have done this, this will be your working directory. Files will be saved (or loaded from) here by default unless you specify a full path. You can change your working directory under the session menu at the top.\nUsing Rstudio has the advantage that everything you do can be saved between RStudio sessions."
  },
  {
    "objectID": "01-start.html#working-in-rstudio",
    "href": "01-start.html#working-in-rstudio",
    "title": "Introduction to RStudio",
    "section": "Working in RStudio",
    "text": "Working in RStudio\nYou can work in 3 different ways in RStudio.\n\nUse the console to run commands.\nCreate a new R script to save your commands as you go.\nCreate a markdown file to generate web pages or pdf documents from your analyses.\n\nCommands can be typed directly into the console, but in order to keep track it’s best to write them into a script and save your progress as you go. You can open a new R script under the File menu at the top left of RStudio."
  },
  {
    "objectID": "01-start.html#running-commands",
    "href": "01-start.html#running-commands",
    "title": "Introduction to RStudio",
    "section": "Running commands",
    "text": "Running commands\nTo run commands directly from your script:\n\nPlace the cursor on the line of code you want to run\nUse the run button above your script\nAlternatively, use the shortcut keys.\n\nAlt + Enter to keep the cursor on the same line\nCtrl + Enter to move to the next line"
  },
  {
    "objectID": "01-start.html#writing-commands",
    "href": "01-start.html#writing-commands",
    "title": "Introduction to RStudio",
    "section": "Writing commands",
    "text": "Writing commands\nAs you write commands, RStudio will try to help you by showing you the syntax of the function you are using and the arguments it takes.\nYou can also use the Tab key to autocomplete names of functions, objects and arguments as you type them.\nWhen using the console, the Up/Down arrow keys can be used to cycle through previously run commands."
  },
  {
    "objectID": "01-start.html#console",
    "href": "01-start.html#console",
    "title": "Introduction to RStudio",
    "section": "Console",
    "text": "Console\nIn the console you should always see a &gt; prompt. This shows that the console is ready to go.\nIf you can’t see this, R may still be working. There is a red Stop light at the top right of the console when a command is running. You can use this or the Esc key to kill a command if it is taking too long or you have made a mistake.\nIf you see a + instead of &gt;, R is waiting for more input. Sometimes this means you have typed the code wrong or forgotten to close a bracket or quotation. You can get back to the &gt; prompt by pressing Esc."
  },
  {
    "objectID": "01-start.html#installing-libraries",
    "href": "01-start.html#installing-libraries",
    "title": "Introduction to RStudio",
    "section": "Installing libraries",
    "text": "Installing libraries\nLibraries provide additional functions in R and can be downloaded from several sources:\n\nCRAN is the Comprehensive R Archive Network and hosts the majority of generic R packages.\nBioconductor is a repository of biology specific packages.\nThird party tools are often hosted on github.\n\nThe examples below show how to install packages from these different sources. You only need to install a package once, but you will need to load it with library every time you start a new R session:\n\n## EXAMPLE ONLY DO NOT RUN\n\n#install from CRAN with install.packages()\ninstall.packages(c(\"tidyverse\", \"ggthemes\"))\n\n#Example to install from bioconductor with BiocManager\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\nBiocManager::install(c(\"DESeq2\",\"genomation\"))\n\nExample to install from github with the devtools package\ninstall.packages(\"devtools\")\ndevtools::install_github(\"thomasp85/patchwork\")\n\nTo load a specific package within an R session, use the library function:\n\nlibrary(tidyverse)\n\nWe will install packages as we move through this course. Each section begins with a list of packages required. We recommend you install these in advance as it can be time consuming and sometimes problematic.\n\n\n How to follow each course\n\n\nCreate a new project in RStudio\nInstall the required libraries\n\nOpen a new R script\nIt will be best to work with the tutorial and RStudio open together so you can easily switch between the two. Working on a wide split-screen or multiple desktops is the best setup.\nI recommend typing out most of the commands rather than copy-and-pasting if you want to learn. Remember you can use the Tab key to save yourself from endless typing!"
  },
  {
    "objectID": "02-IntroR.html",
    "href": "02-IntroR.html",
    "title": "Introduction to R",
    "section": "",
    "text": "What is R?\nUnderstand R datatypes and classes\nUnderstand how to use functions in base R\nImport datasets into R\nInspect and format a dataset\nCreate basic graphics\nRun statistical tests"
  },
  {
    "objectID": "02-IntroR.html#what-is-r",
    "href": "02-IntroR.html#what-is-r",
    "title": "Introduction to R",
    "section": "What is R?",
    "text": "What is R?\nR is an extremely powerful programming language for data science, statistical analysis and data visualisation. It is favoured by biologists due to its extensive library of packages for bioinformatics and genomic analysis. In this lesson you will learn how to program and interact with data in R. We will cover the basics of the R syntax, using its built in packages (base R)."
  },
  {
    "objectID": "02-IntroR.html#why-is-r-useful",
    "href": "02-IntroR.html#why-is-r-useful",
    "title": "Introduction to R",
    "section": "Why is R useful?",
    "text": "Why is R useful?\n\nIt’s free! open source software.\nIt’s Powerful. There are many libraries for application specific tasks.\n\nBioconductor is a repository for bioinformatics R software.\nTidyverse is a suite of packages for data science with a shared philosophy for storing, manipulating and visualising data.\n\nPresentation quality graphics\n\nSave as a png, pdf or svg for use in publications and presentations.\n\nGenerate reproducible and persistent results\n\nR commands and analyses can be saved for reproducible and persistent analyses.\nCreate automated scripts to replicate analysis on different datasets.\n\nRStudio provides an interactive environment for working in R.\nR markdown can generate documents to present your analyses as reports.\nShiny can produce interactive applications for exploratory data analysis."
  },
  {
    "objectID": "02-IntroR.html#working-directory",
    "href": "02-IntroR.html#working-directory",
    "title": "Introduction to R",
    "section": "Working directory",
    "text": "Working directory\nThis is the directory used to store your data and results. This is where R will look for files to read in and where it will save any output files. You can check your current working directory with the getwd() function.\n\ngetwd()\n\nIf you want to change the working directory you can use setwd(\"/path/to/new_directory\") or use the session menu in RStudio."
  },
  {
    "objectID": "02-IntroR.html#data-types",
    "href": "02-IntroR.html#data-types",
    "title": "Introduction to R",
    "section": "Data Types",
    "text": "Data Types\nValues in R are assigned a data type which tells R how to interpret them. Some common data types are:\n\nnumeric: Numbers\ncharacter: Strings of text\nfactor: Labels for categorical data (e.g. species, sex)\nlogical: TRUE or FALSE values"
  },
  {
    "objectID": "02-IntroR.html#data-structures",
    "href": "02-IntroR.html#data-structures",
    "title": "Introduction to R",
    "section": "Data Structures",
    "text": "Data Structures\nR uses different data structures to organise data. Common structures are shown below.\n\nVector\n\nA collection of values of one data type\nEquivalent to a column in a table\nItems in the vector can be named\nE.g. A collection of recorded mouse weights\n\n\n## numeric vector\nc(12.3, 15.6, 9.8, 7.4) \n\n[1] 12.3 15.6  9.8  7.4\n\n## A named vector\nc(M1=12.3, M2=15.6, M3=9.8, M4=7.4)\n\n  M1   M2   M3   M4 \n12.3 15.6  9.8  7.4 \n\n\n\n\nData Frame\n\nA table\nEssentially a collection of vectors as columns\nColumns can be different data types\nColumns must have the same length\nE.g. A table of mouse weights with columns (Mouse_ID (character), Sex (factor), Weight (numeric))\n\n\ndata.frame(\n  Mouse_ID = c(\"M1\", \"M2\", \"M3\"),\n  Sex = factor(c(\"M\", \"F\", \"F\")), # use the factor function to tell R that this is categorical data\n  Weight = c(12.3, 15.6, 9.8)\n)\n\n  Mouse_ID Sex Weight\n1       M1   M   12.3\n2       M2   F   15.6\n3       M3   F    9.8\n\n\n\n\nMatrix\n\nA table where all values are related and of the same data type\nCommonly used for correlation and heatmap analysis\nE.g. A table of RNA-seq expression levels where each row is a gene and each column is a different sample.\n\n\nmatrix &lt;- matrix(c(5, 2, 3, 8, 7, 4), nrow=2)\nrownames(matrix) &lt;- c(\"GeneA\", \"GeneB\")\ncolnames(matrix) &lt;- c(\"Sample1\", \"Sample2\", \"Sample3\")\n\nmatrix\n\n      Sample1 Sample2 Sample3\nGeneA       5       3       7\nGeneB       2       8       4\n\n\n\n\nList\n\nLists are collections of R objects.\nEach item in the list has a unique index or name.\nA list can contain items of different object types and classes (e.g single values, vectors, data frames, matrices, other lists…).\nE.g. A list containing a data frame of sample information, a matrix of expression values and a vector of gene names.\n\n\nlist(\n  sample_info = data.frame(SampleID=c(\"Sample1\",\"Sample2\"), Condition=factor(c(\"Control\",\"Treated\"))), # data frame\n  expression_matrix = matrix(c(5,2,3,8), nrow=2), # matrix of expression values\n  gene_names = c(\"GeneA\", \"GeneB\") # vector\n)\n\n$sample_info\n  SampleID Condition\n1  Sample1   Control\n2  Sample2   Treated\n\n$expression_matrix\n     [,1] [,2]\n[1,]    5    3\n[2,]    2    8\n\n$gene_names\n[1] \"GeneA\" \"GeneB\""
  },
  {
    "objectID": "02-IntroR.html#r-syntax",
    "href": "02-IntroR.html#r-syntax",
    "title": "Introduction to R",
    "section": "R Syntax",
    "text": "R Syntax\nR is a functional programming language:\n\nNearly every command is the name of a function followed by parentheses.\nThe inputs to a function, including different options, are placed in the brackets.\nYou can use the Tab key to see the options available or use the help documentation for each function.\n\nTypical command structure:\n\nfunction_name(data, options, moreOptions)\n\nLet’s run a function on a real data set. The cars data set is built into base R. We can look at it by typing its name.\n\ncars\n\n   speed dist\n1      4    2\n2      4   10\n3      7    4\n4      7   22\n5      8   16\n6      9   10\n7     10   18\n8     10   26\n9     10   34\n10    11   17\n11    11   28\n12    12   14\n13    12   20\n14    12   24\n15    12   28\n16    13   26\n17    13   34\n18    13   34\n19    13   46\n20    14   26\n21    14   36\n22    14   60\n23    14   80\n24    15   20\n25    15   26\n26    15   54\n27    16   32\n28    16   40\n29    17   32\n30    17   40\n31    17   50\n32    18   42\n33    18   56\n34    18   76\n35    18   84\n36    19   36\n37    19   46\n38    19   68\n39    20   32\n40    20   48\n41    20   52\n42    20   56\n43    20   64\n44    22   66\n45    23   54\n46    24   70\n47    24   92\n48    24   93\n49    24  120\n50    25   85\n\n\nWe can see that this is a table of values. If we run the class function we will see that R recognises this as a data.frame.\n\nclass(cars)\n\n[1] \"data.frame\"\n\n\nNow let’s run a more useful function. The plot function in R is used for making basic graphs. It also has additional arguments which can be altered to change its behaviour. Try plotting the cars data.\n\n## Use the options within the plot function to customise the output\nplot(cars, xlab = \"Car Speed (mph)\", ylab = \"Stopping Distance (ft)\")\n\n\n\n\n\n\n\n\nNot all functions need arguments. For instance, the getwd function which returns the path of your working directory.\n\ngetwd()"
  },
  {
    "objectID": "02-IntroR.html#storing-objects",
    "href": "02-IntroR.html#storing-objects",
    "title": "Introduction to R",
    "section": "Storing objects",
    "text": "Storing objects\nWe can create objects in R to store data or the output of functions. This is useful for saving data that we want to use later on, or for storing intermediate steps in an analysis.\nWe can use the = sign or &lt;- to store the output of a function as an object.\n\n## These statements are identical\nresult = function_name(data, options, moreOptions)\nresult &lt;- function_name(data, options, moreOptions)\n\nTry storing the output of the summary function on the cars data set. You will see the object sum_cars appear in your Environment tab in RStudio.\n\nsum_cars = summary(cars)\n\nTo see what this object holds, just type its name.\n\nsum_cars\n\n     speed           dist       \n Min.   : 4.0   Min.   :  2.00  \n 1st Qu.:12.0   1st Qu.: 26.00  \n Median :15.0   Median : 36.00  \n Mean   :15.4   Mean   : 42.98  \n 3rd Qu.:19.0   3rd Qu.: 56.00  \n Max.   :25.0   Max.   :120.00"
  },
  {
    "objectID": "02-IntroR.html#getting-help",
    "href": "02-IntroR.html#getting-help",
    "title": "Introduction to R",
    "section": "Getting help",
    "text": "Getting help\nR has extensive built in help documentation. You can access this using the help function. The command below provides the help page for the function read.table\n\nhelp(read.table)\n\nWe can also search the help documentation using help.search. Let’s see if we can find a function for running a t-test.\n\nhelp.search(\"t test\")\n\nNOTE quotes are required around strings of text. You do not need to use quotes when referring to names of R data objects or functions.\nThere is a short cut for help, ?, which shows the help page for a function.\n\n# same as help(read.table)\n?read.table\n\n?? searches for help pages on functions, same as help.search(“phrase”)\n\n# same as help.search(\"t test\")\n??\"t test\"\n\nYou can also use the Help tab in RStudio to search for help on functions, or search online.\n\n\n Key points\n\n\nData types: Understand different data types (numeric, character, factor, logical)\nR objects: Understand different ways to structure data in R (vectors, dataframes, matrices, lists). There are several other types of R object.\nFunctions: Code in R is run within functions.\nHelp: Use the help features to find out how a function works."
  },
  {
    "objectID": "02-IntroR.html#getting-data-into-r",
    "href": "02-IntroR.html#getting-data-into-r",
    "title": "Introduction to R",
    "section": "Getting data into R",
    "text": "Getting data into R\nGetting data into R is often the first step in any analysis.\nIt is possible to create a vector of data by typing directly into R using the function c. The c stands for combine and can be used to combine values into a vector.\n\nx   &lt;-  c(1,2,3,4,5)\n\nThis creates a vector named ‘x’ which stores the numbers 1 through to 5.\nYou can see what is in an object at any time by typing its name:\n\nx\n\n[1] 1 2 3 4 5\n\n\nCharacter values need to be quoted, otherwise R will look for a data object of that name.\n\n## This produces an error because R is looking for objects called Monday, Tuesday etc. which do not exist.\ndaysofweek &lt;- c(Monday, Tuesday, Wednesday, Thursday, Friday)\n\n\n## This works\ndaysofweek &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\nYou can create data frames from vectors using the data.frame function:\n\ntable &lt;- data.frame(Index = x, Day = daysofweek)\n\ntable\n\n  Index       Day\n1     1    Monday\n2     2   Tuesday\n3     3 Wednesday\n4     4  Thursday\n5     5    Friday\n\n\nUsually however, you will want to input data from a file. You can read files on your computer or from a URL. Use the read.table function to read in the table hosted at the URL below.\n\nread.table(\"http://bifx-core3.bio.ed.ac.uk/data.tsv\")\n\nR reads this table as a data.frame object and prints it to the R console by default. To save the table, we need to assign it to an object.\n\nmydata  &lt;- read.table(\"http://bifx-core3.bio.ed.ac.uk/data.tsv\")\n\nHere, mydata is an object name and the syntax &lt;- assigns the output of the function to it. Remember you can also use =.\nR stores mydata as a data frame, containing multiple vectors. We can check the class of our object using the class() function. The Environment tab in RStudio can also be used to explore objects and their properties.\n\nclass(mydata)\n\n[1] \"data.frame\"\n\n\nWe can look at our table by typing its name, but this prints a lot of rows. Using the head() function will only print the first few lines;\n\nhead(mydata, n=5)\n\n  V1 V2 V3 V4 V5\n1  A  B  C  D  E\n2  1  4  1  1  1\n3  2  5  1  1  2\n4  2  5  1  1  2\n5  3  6  1  2  3\n\n\nYou can also use the View() command to open data frames in the file pane.\nHmmm, something isn’t right with our rows here…\nBy default the read.table function assumes certain things from the file\n\nThe file is a plain text file (there are separate functions to read excel files etc.)\nColumns are separated by any number of tabs or spaces\nThere are the same number of data points in each column\nThere is no header row (labels for the columns)\nThere is no column with names for the rows\n\nIf any of these are FALSE, then we need to give that information to the function. If it has a header column use the ‘header=TRUE’ argument.\n\nmydata &lt;- read.table(\"http://bifx-core3.bio.ed.ac.uk/data.tsv\", header=TRUE)  \n\n# Note that header=T will also work here. TRUE and FALSE can be abbreviated to T and F in R.\n\nNote the comma between different parts of the functions arguments.\nThis overwrites our previous data frame mydata with the correctly formatted one. Let’s look at the first 5 rows again.\n\nhead(mydata, n=5)\n\n  A B C D E\n1 1 4 1 1 1\n2 2 5 1 1 2\n3 2 5 1 1 2\n4 3 6 1 2 3\n5 3 6 1 2 3\n\n\nNow we can see that the first row contains the column labels (A, B, C, D, E). R has automatically assigned default row names (1, 2, 3 etc.)\n\nOther options for read.table\nUse sep = to define how columns are separated in your input file. This file uses the tab character which we can write as “\\t”.\n\nmydata  &lt;- read.table(\"http://bifx-core3.bio.ed.ac.uk/data.tsv\", header = T, sep = \"\\t\")\n\nBy default, read.table assumes columns are separated by any amount of white space (space or tabs). This can lead to problems if some of your columns have missing values, so it is good practice to always give a sep argument.\nIf your data has missing values you can use fill = TRUE.\n\nmydata  &lt;- read.table(\"http://bifx-core3.bio.ed.ac.uk/data.tsv\", header = T, sep = \"\\t\", fill = T)\n\nThis tells R to fill empty spaces in columns with the ‘NA’ character.\nAs this is such a common task there are functions identical to read.table but with different default settings. e.g. read.delim and read.csv. Check out the help pages for each of these.\n\n\nImporting Datasets\nIn the Environment pane in RStudio there is a button called Import Dataset. This can make importing data much easier and calls the read.* set of functions for you. The command used will be displayed on the console. Make sure you save this code so that you can easily re-run the analysis later.\nNote that you need to have the file on the computer to use this button."
  },
  {
    "objectID": "02-IntroR.html#inspect-and-summarise-data",
    "href": "02-IntroR.html#inspect-and-summarise-data",
    "title": "Introduction to R",
    "section": "Inspect and summarise data",
    "text": "Inspect and summarise data\nLet’s use some simple functions to inspect and summarise our data.\n\nstr(mydata) # Shows the structure of a data frame and the data types of each column\n\n'data.frame':   27 obs. of  5 variables:\n $ A: int  1 2 2 3 3 3 3 3 4 4 ...\n $ B: int  4 5 5 6 6 6 6 6 7 7 ...\n $ C: int  1 1 1 1 1 1 1 1 1 1 ...\n $ D: int  1 1 1 2 2 2 2 2 2 2 ...\n $ E: int  1 2 2 3 3 4 3 3 4 4 ...\n\n\n\nsummary(mydata) # Summarises the values in each column \n\n       A               B                C               D        \n Min.   :1.000   Min.   : 4.000   Min.   :1.000   Min.   :1.000  \n 1st Qu.:3.000   1st Qu.: 6.000   1st Qu.:1.000   1st Qu.:2.000  \n Median :4.000   Median : 7.000   Median :1.000   Median :3.000  \n Mean   :4.296   Mean   : 7.296   Mean   :1.778   Mean   :3.333  \n 3rd Qu.:5.000   3rd Qu.: 8.000   3rd Qu.:2.000   3rd Qu.:4.000  \n Max.   :8.000   Max.   :11.000   Max.   :5.000   Max.   :9.000  \n       E        \n Min.   :1.000  \n 1st Qu.:3.500  \n Median :4.000  \n Mean   :4.407  \n 3rd Qu.:5.000  \n Max.   :8.000  \n\n\nIndividual columns in a data frame can be accessed using the $ sign (mydata$A mydata$B etc.)\n\nmydata$A # Prints all values in column A\n\n [1] 1 2 2 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 6 6 6 7 7 8\n\n\n\nsummary(mydata$A) # Summary information for column A only\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.000   3.000   4.000   4.296   5.000   8.000 \n\n\n\nmean(mydata$A) # Mean of column A\n\n[1] 4.296296\n\n\nTry some other summary functions like mean, median, min and max."
  },
  {
    "objectID": "02-IntroR.html#square-bracket-notation",
    "href": "02-IntroR.html#square-bracket-notation",
    "title": "Introduction to R",
    "section": "Square bracket notation",
    "text": "Square bracket notation\nWe can access specific rows, columns and cells within a data frame using square brackets: TABLE[ROW,COLUMN]. You can experiment with this notation by trying out the following commands.\n\n## Print the value in the first column of the first row\nmydata[1,1]\n\n## Use blanks to print an entire row or column\nmydata[2,]\nmydata[,3]\n\n## You can select multiple rows and columns with ranges (:) or the c() function\n## E.g. Print the first 5 rows of columns 3 and 5\nmydata[1:5,c(3,5)]\n\n## You can also use row or column names instead of numbers\nmydata[,\"B\"]\n\n## You can select rows or columns based on certain criteria (subsetting).\n## E.g. Select all rows where B is greater than 7\nmydata[mydata$B &gt; 7,]"
  },
  {
    "objectID": "02-IntroR.html#ordering-data",
    "href": "02-IntroR.html#ordering-data",
    "title": "Introduction to R",
    "section": "Ordering data",
    "text": "Ordering data\nThe order function can be used to sort data frames by a specific column.\n\norder(mydata$B) # Returns the row numbers in the sorted order of column B\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27\n\n# We can use this in the row index position to sort the entire data frame by column B\nmydata[order(mydata$B), ]\n\n   A  B C D E\n1  1  4 1 1 1\n2  2  5 1 1 2\n3  2  5 1 1 2\n4  3  6 1 2 3\n5  3  6 1 2 3\n6  3  6 1 2 4\n7  3  6 1 2 3\n8  3  6 1 2 3\n9  4  7 1 2 4\n10 4  7 1 2 4\n11 4  7 1 2 4\n12 4  7 1 2 5\n13 4  7 1 2 5\n14 4  7 1 3 4\n15 4  7 1 3 4\n16 4  7 1 3 4\n17 4  7 2 3 4\n18 5  8 2 3 5\n19 5  8 2 4 5\n20 5  8 2 4 5\n21 5  8 2 4 5\n22 6  9 3 5 6\n23 6  9 3 5 6\n24 6  9 3 6 6\n25 7 10 4 7 7\n26 7 10 4 8 7\n27 8 11 5 9 8\n\n\n\n\n Challenge:\n\n\nSee if you can do the following:\n\nSelect the 11th value in the third column\nSelect all rows where D equals 4 (hint; use ‘==’)\nSelect rows where B has its maximum value (hint: use the max function)\nSelect even numbered rows only (hint: take a look at the seq function ‘?seq()’)\nSelect columns A, C and E\nSort table by decreasing order of column B (hint: look at the options in the order function)\n\n\n\n\n\nSolution. \n\n Solution:\n\n\nSelect row 11, column 3\n\n\nmydata[11,3]\n\n[1] 1\n\n\n\nSelect rows where D 3 equals 4\n\n\nmydata[mydata$D == 4,] \n\n   A B C D E\n19 5 8 2 4 5\n20 5 8 2 4 5\n21 5 8 2 4 5\n\n## Note the use of \"==\" for equality testing. This is a standard programming convention.\n\n\nSelect rows where B has its maximum value\n\n\nmydata[mydata$B == max(mydata$B), ]\n\n   A  B C D E\n27 8 11 5 9 8\n\n\n\nSelect even numbered rows only\n\n\nmydata[seq(2,26, by = 2), ]\n\n   A  B C D E\n2  2  5 1 1 2\n4  3  6 1 2 3\n6  3  6 1 2 4\n8  3  6 1 2 3\n10 4  7 1 2 4\n12 4  7 1 2 5\n14 4  7 1 3 4\n16 4  7 1 3 4\n18 5  8 2 3 5\n20 5  8 2 4 5\n22 6  9 3 5 6\n24 6  9 3 6 6\n26 7 10 4 8 7\n\n\n\nSelect columns A, C and E\n\n\nmydata[, c(1,3,5)] \n\n   A C E\n1  1 1 1\n2  2 1 2\n3  2 1 2\n4  3 1 3\n5  3 1 3\n6  3 1 4\n7  3 1 3\n8  3 1 3\n9  4 1 4\n10 4 1 4\n11 4 1 4\n12 4 1 5\n13 4 1 5\n14 4 1 4\n15 4 1 4\n16 4 1 4\n17 4 2 4\n18 5 2 5\n19 5 2 5\n20 5 2 5\n21 5 2 5\n22 6 3 6\n23 6 3 6\n24 6 3 6\n25 7 4 7\n26 7 4 7\n27 8 5 8\n\n## Or mydata[,c('A','C','E')] \n\n\nSort table by decreasing order of column B\n\n\nmydata[order(mydata$B, decreasing = TRUE), ]\n\n   A  B C D E\n27 8 11 5 9 8\n25 7 10 4 7 7\n26 7 10 4 8 7\n22 6  9 3 5 6\n23 6  9 3 5 6\n24 6  9 3 6 6\n18 5  8 2 3 5\n19 5  8 2 4 5\n20 5  8 2 4 5\n21 5  8 2 4 5\n9  4  7 1 2 4\n10 4  7 1 2 4\n11 4  7 1 2 4\n12 4  7 1 2 5\n13 4  7 1 2 5\n14 4  7 1 3 4\n15 4  7 1 3 4\n16 4  7 1 3 4\n17 4  7 2 3 4\n4  3  6 1 2 3\n5  3  6 1 2 3\n6  3  6 1 2 4\n7  3  6 1 2 3\n8  3  6 1 2 3\n2  2  5 1 1 2\n3  2  5 1 1 2\n1  1  4 1 1 1"
  },
  {
    "objectID": "02-IntroR.html#filtering-data",
    "href": "02-IntroR.html#filtering-data",
    "title": "Introduction to R",
    "section": "Filtering data",
    "text": "Filtering data\nSquare bracket notation can be handy for quickly filtering data frames or checking values, but can get cumbersome for more complex queries.\nThere is a subset() function in R specifically for filtering tables. This generally works better than using square brackets as it copes well with NA and NULL values.\n\nsubset(mydata, mydata$C == 3)\n\n   A B C D E\n22 6 9 3 5 6\n23 6 9 3 5 6\n24 6 9 3 6 6\n\n\nThe tidyverse packages have their own set of functions for filtering data and we will explore these in a later module."
  },
  {
    "objectID": "02-IntroR.html#plotting-with-r",
    "href": "02-IntroR.html#plotting-with-r",
    "title": "Introduction to R",
    "section": "Plotting with R",
    "text": "Plotting with R\nBase R has many built in functions for plotting data.\nWe recommend learning ggplot2 for more complex graphics but it is useful to know what base R offers. Remember, to get more information about the options available to a function, type ?function.\n\nHistograms\n\nhist(mydata$A)\n\n\n\n\n\n\n\n\nThe ChickWeight data set is another data frame built into R. It is a larger dataset, containing the weights of chicks on different diets, measured over time. Inspect the ChickWeight data using some of the functions you have used already.\n\n\n Challenge:\n\n\nWhat type of data is stored in the weight column?\nWhat is the mean weight of all the chicks?\nWhat type of data is stored in the Diet column?\nHow many rows are in this table (try the dim or nrow functions)?\n\n\n\n\n\nSolution. \n\n Solution:\n\n\nWhat type of data is stored in the weight column?\n\n\nclass(ChickWeight$weight)\n\n[1] \"numeric\"\n\n\n\nWhat is the mean weight of all the chicks?\n\n\nmean(ChickWeight$weight)\n\n[1] 121.8183\n\n\n\nWhat type of data is stored in the Diet column?\n\n\nclass(ChickWeight$Diet)\n\n[1] \"factor\"\n\n\n\nHow many rows are in this table (try the dim or nrow functions)?\n\n\nnrow(ChickWeight)\n\n[1] 578\n\n\n\n\n\n\n\nhist(ChickWeight$weight)\n\n\n\n\n\n\n\n\nWe can modify the number of vertical columns in a histogram with the argument breaks, to give us increased resolution.\n\nhist(ChickWeight$weight, breaks = 50)\n\n\n\n\n\n\n\n\n\n\nBoxplots\n\nboxplot(mydata)\n\n\n\n\n\n\n\n\n\nboxplot(mydata$A, mydata$B, names=c(\"Value A\", \"Value B\") , ylab=\"Count of Something\")\n\n\n\n\n\n\n\n\n\n\nScatter plots\n\nplot(x = mydata$A, y = mydata$B)\n\n\n\n\n\n\n\n\nTake a look at ?plot. You will see that the first argument is ‘x’ and the second is ‘y’. If you don’t name the arguments, the function will assume that the first argument is ‘x’ and the second is ‘y’.\n\n## This works because the first variable is assumed to be x and the second y\nplot(mydata$A, mydata$B)\n\nIf you name the arguments, you can put them in any order.\n\n## This works because the arguments are named\nplot(y = mydata$B, x = mydata$A)\n\nEarlier, we used the plot function with a single x argument: plot(cars). This worked because the x argument also accepts a data frame and will plot all combinations of columns. Try this for mydata and see what happens.\n\nplot(mydata)"
  },
  {
    "objectID": "02-IntroR.html#saving-images",
    "href": "02-IntroR.html#saving-images",
    "title": "Introduction to R",
    "section": "Saving images",
    "text": "Saving images\nThere are a few ways to save images in RStudio:\n\nUse the export button in the Plots pane in Rstudio.\n\nEasy to perform.\nDoesn’t work well for automated scripts.\nNo reproducible code to show how the image was generated.\n\n\n\nUse a graphics device function in your R code.\nUse the png function to save a png file (easy to load into web applications and presentations).\n\npng(\"filename.png\") \nboxplot(A, B, names=c(\"Value A\", \"Value B\") , ylab=\"Count of Something\")\ndev.off()\n\nThe dev.off() function closes the graphics device. In the code above, everything between png() and dev.off() is saved to ‘filename.png’.\nYou can also save as a pdf.\n\npdf(\"filename.pdf\") \nboxplot(A, B, names=c(\"Value A\", \"Value B\") , ylab=\"Count of Something\")\ndev.off()"
  },
  {
    "objectID": "02-IntroR.html#statistical-testing",
    "href": "02-IntroR.html#statistical-testing",
    "title": "Introduction to R",
    "section": "Statistical testing",
    "text": "Statistical testing\nR has many functions for statistical testing. We will cover a couple of examples here, but there are many more to explore. Remember, to get more information about the options available to a function, type ?function.\n\nT-test\nThe t.test function can be used to compare the numerical means of two groups. The t-test should only be used under the following assumptions.\n\nEach group is approximately normally distributed\nThe variance of the two groups is approximately equal\nThe two groups are independent of each other\n\nWe can use R to simulate a data frame of values for two groups, WT and KO, with 10 values in each group (this could be any sort of experimental measurement).\nBelow, we use the rnorm function to generate random numbers from a normal distribution. The mean and sd arguments specify the mean and standard deviation of the distribution.\n\nset.seed(123) # Set seed for reproducibility.\n\ndf &lt;- data.frame(\n  Sample = paste(\"Sample\", 1:20, sep=\"_\"),\n  Group = rep(c(\"WT\", \"KO\"), each=10),\n  Value = c(rnorm(10, mean=5, sd=1), rnorm(10, mean=6, sd=1))\n)\ndf\n\n      Sample Group    Value\n1   Sample_1    WT 4.439524\n2   Sample_2    WT 4.769823\n3   Sample_3    WT 6.558708\n4   Sample_4    WT 5.070508\n5   Sample_5    WT 5.129288\n6   Sample_6    WT 6.715065\n7   Sample_7    WT 5.460916\n8   Sample_8    WT 3.734939\n9   Sample_9    WT 4.313147\n10 Sample_10    WT 4.554338\n11 Sample_11    KO 7.224082\n12 Sample_12    KO 6.359814\n13 Sample_13    KO 6.400771\n14 Sample_14    KO 6.110683\n15 Sample_15    KO 5.444159\n16 Sample_16    KO 7.786913\n17 Sample_17    KO 6.497850\n18 Sample_18    KO 4.033383\n19 Sample_19    KO 6.701356\n20 Sample_20    KO 5.527209\n\n\n\n\n Discussion\n\nWhat is a normal distribution? How does rnorm work?\nWhat does set.seed do?\nWhat do the paste and rep functions do?\n\n\nWe can use the t.test function to compare the means of the two groups. The syntax for the t-test is t.test(Value ~ Group, data=df), where Value is the numeric variable we want to compare and Group is the categorical variable that defines the groups.\n\nt.test(Value ~ Group, data = df, var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  Value by Group\nt = 2.5438, df = 18, p-value = 0.02036\nalternative hypothesis: true difference in means between group KO and group WT is not equal to 0\n95 percent confidence interval:\n 0.1974232 2.0705694\nsample estimates:\nmean in group KO mean in group WT \n        6.208622         5.074626 \n\n\n\n\n Discussion\n\nHow do we interpret the output of the t-test?\nAre the mean values of the WT and KO groups significantly different?\n\n\n\n\nFisher’s exact test\nThe fisher.test function can be used to test for association between two categorical variables.\n\nExample\nResearchers are testing a new anti-cancer drug in a mouse model. Tumour-bearing mice are randomly assigned to one of two treatment groups:\n\nControl (vehicle only)\nDrug-treated\n\nAfter 4 weeks of treatment, tumours are assessed for response. Each mouse is classified as:\n\nResponder (tumour size reduced ≥ 30%)\nNon-responder (tumour did not shrink sufficiently)\n\nBoth variables are categorical:\n\nTreatment: Control / Drug\nResponse: Responder / Non-responder\n\nLet’s create a contingency table of the two categorical variables, Treatment and Response, and use the fisher.test function to test for an association between them.\n\n# Create a contingency table\n\nct &lt;- matrix(\n  c(3, 17,   # Control: Responder, Non-responder\n    12, 8),  # Drug: Responder, Non-responder\n  nrow = 2,\n  byrow = TRUE\n)\n\nrownames(ct) &lt;- c(\"Control\", \"Drug\")\ncolnames(ct) &lt;- c(\"Responder\", \"Non_responder\")\n\nct\n\n        Responder Non_responder\nControl         3            17\nDrug           12             8\n\n\nNow we can perform the test on this contingency table.\n\nfisher.test(ct)\n\n\n    Fisher's Exact Test for Count Data\n\ndata:  ct\np-value = 0.007912\nalternative hypothesis: true odds ratio is not equal to 1\n95 percent confidence interval:\n 0.01758347 0.63708839\nsample estimates:\nodds ratio \n 0.1250459 \n\n\n\n\n Discussion\n\nIs there a significant association between treatment and response?"
  },
  {
    "objectID": "02-IntroR.html#case-study-quantitative-pcr",
    "href": "02-IntroR.html#case-study-quantitative-pcr",
    "title": "Introduction to R",
    "section": "Case Study: Quantitative PCR",
    "text": "Case Study: Quantitative PCR\nQuantitative PCR (qPCR) is a laboratory technique used to measure how much of a specific sequence is present in a sample. In gene expression experiments, RNA is first converted to complementary DNA (cDNA), and then qPCR is used to quantify how much of a particular gene is expressed.\nUnlike traditional PCR, qPCR measures amplification in real time using fluorescent dyes or probes. As DNA is amplified during each cycle, fluorescence increases. The instrument monitors this fluorescence and determines when it rises above a defined background threshold.\nThe key measurement in qPCR is the Ct value (Cycle threshold). The Ct is the number of PCR cycles required for fluorescence to cross a detection threshold. It is inversely related to the amount of starting material.\n\nInterpretation\n\nLow Ct → lots of starting material → high gene expression\nHigh Ct → little starting material → low gene expression\n\nFor example:\n\n\n\nSample\nCt value\nInterpretation\n\n\n\n\nSample A\n18\nHigh expression\n\n\nSample B\n25\nModerate expression\n\n\nSample C\n32\nLow expression\n\n\n\nEach PCR cycle approximately doubles the amount of DNA. That means:\n\nA difference of 1 Ct ≈ 2-fold difference in starting quantity\nA difference of 3 Ct ≈ ~8-fold difference\nA difference of 10 Ct ≈ ~1000-fold difference\n\n\n\nReference gene normalisation\nBiological samples vary in:\n\nTotal RNA amount\nRNA quality\nPipetting variation\n\nTo control for this, we measure a reference (housekeeping) gene that should not change between conditions.\nWe then calculate ΔCt by subtracting the Ct of the reference gene from the Ct of the target gene for each sample.\n\\[\nΔCt = Ct_{target} - Ct_{reference}\n\\]\n\n\nComparing conditions\nTo compare gene expression between conditions, we calculate the difference between the ΔCt of the treatment group and the ΔCt of the control group, which is called ΔΔCt:\n\\[\nΔΔCt = ΔCt_{treatment} - ΔCt_{control}\n\\]\nWe can then calculate the fold change in expression using the following formula:\n\\[\nFold~Change = 2^{-ΔΔCt}\n\\]\n\n\nStep 1: Load the data\nOur qPCR data consists of Ct values for a gene of interest and a reference gene, across 16 samples, split into two conditions (Control and Treatment). We will use this data to compare gene expression between the two conditions.\nYou can download the data from the URL below and save it in a new folder in your working directory.\n\n## Create a folder in the working directory\ndir.create(\"data\")\n\n## Download the qPCR file and save it in the data folder\ndownload.file(\"http://bifx-core3.bio.ed.ac.uk/training/DSB/data/qPCR_data.xlsx\", destfile = \"data/qpcr_data.xlsx\")\n\nOur data is in an Excel spreadsheet. We could open Excel and export the data as a tab delimited text file, then read it in using read.table or read.delim. However, R has a useful package called readxl for importing Excel files directly.\nTo access this package, we first need to install it:\n\ninstall.packages(\"readxl\")\n\nWe can now load the package and use the readxl functions in our current R session.\n\nlibrary(readxl)\n\n\n\n Challenge:\n\nUse a function in readxl to read in the qPCR data from the Excel file you downloaded. You can use the help documentation to find out how to do this.\n\nHow many rows and columns are in the data frame?\nWhat are the column names?\nHow many conditions are there and what are they called?\nHow many biological replicates do we have for each condition?\nWhat is the mean Ct value for the gene of interest in the control samples?\n\n\n\n\n\nSolution. \n\n Solution:\n\nRead in the qpcr data and inspect it using the functions we have already seen.\n\nqpcr &lt;- read_excel(\"data/qPCR_data.xlsx\")\nstr(qpcr)\n\ntibble [16 × 4] (S3: tbl_df/tbl/data.frame)\n $ Sample_ID: chr [1:16] \"S1\" \"S2\" \"S3\" \"S4\" ...\n $ Condition: chr [1:16] \"Control\" \"Control\" \"Control\" \"Control\" ...\n $ ct_gene  : num [1:16] 25.4 24.9 25.1 25.6 24.8 25.2 25 25.3 23.7 23.5 ...\n $ ct_ref   : num [1:16] 20.2 20.1 20.3 20 20.1 20.2 20 20.1 20.2 20 ...\n\nsummary(qpcr)\n\n  Sample_ID          Condition            ct_gene          ct_ref     \n Length:16          Length:16          Min.   :23.30   Min.   :20.00  \n Class :character   Class :character   1st Qu.:23.57   1st Qu.:20.07  \n Mode  :character   Mode  :character   Median :24.35   Median :20.10  \n                                       Mean   :24.38   Mean   :20.12  \n                                       3rd Qu.:25.12   3rd Qu.:20.20  \n                                       Max.   :25.60   Max.   :20.30  \n\n\n\nHow many rows and columns are in the data frame?\n\n\ndim(qpcr)\n\n[1] 16  4\n\n\n\nWhat are the column names?\n\n\ncolnames(qpcr)\n\n[1] \"Sample_ID\" \"Condition\" \"ct_gene\"   \"ct_ref\"   \n\n\n\nHow many conditions are there and what are they called?\n\n\n## The unique function gives the unique values in a vector\nunique(qpcr$Condition)\n\n[1] \"Control\"   \"Treatment\"\n\n\n\nHow many biological replicates do we have for each condition?\n\n\n## Show a table of the number of entries for each condition\ntable(qpcr$Condition)\n\n\n  Control Treatment \n        8         8 \n\n## Or convert Condition to a factor and use summary\nsummary(as.factor(qpcr$Condition))\n\n  Control Treatment \n        8         8 \n\n\n\nWhat is the mean Ct value for the gene of interest in the control samples?\n\n\nmean(qpcr$ct_gene[qpcr$Condition == \"Control\"])\n\n[1] 25.1625\n\n\n\n\n\n\n\n\nStep 2: Calculate ΔCt\nTo calculate ΔCt, we need to subtract the Ct value of the reference gene from the Ct value of the gene of interest for each sample.\nWe can create new columns in a data frame using the $ symbol.\n\n## This operation is performed on each row of the data frame, so we get a new column with the ΔCt values for each sample.\nqpcr$delta_ct &lt;- qpcr$ct_gene - qpcr$ct_ref\n\nqpcr\n\n# A tibble: 16 × 5\n   Sample_ID Condition ct_gene ct_ref delta_ct\n   &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n 1 S1        Control      25.4   20.2      5.2\n 2 S2        Control      24.9   20.1      4.8\n 3 S3        Control      25.1   20.3      4.8\n 4 S4        Control      25.6   20        5.6\n 5 S5        Control      24.8   20.1      4.7\n 6 S6        Control      25.2   20.2      5  \n 7 S7        Control      25     20        5  \n 8 S8        Control      25.3   20.1      5.2\n 9 S9        Treatment    23.7   20.2      3.5\n10 S10       Treatment    23.5   20        3.5\n11 S11       Treatment    23.8   20.1      3.7\n12 S12       Treatment    23.4   20.2      3.2\n13 S13       Treatment    23.6   20.1      3.5\n14 S14       Treatment    23.9   20        3.9\n15 S15       Treatment    23.3   20.2      3.1\n16 S16       Treatment    23.5   20.1      3.4\n\n\nA new column delta_ct has been added to the data frame, which contains the ΔCt values for each sample.\n\n\nStep 3: Visualise the data\nWe can use a boxplot to visualise the ΔCt values in the control and treatment samples.\n\nboxplot(delta_ct ~ Condition, data = qpcr,\n        ylab = \"Delta Ct\",\n        main = \"Gene expression by condition\")\n\n\n\n\n\n\n\n\nWe can clearly see a difference between the two conditions, but is this difference statistically significant? We can use a t-test to find out.\n\n\nStep 4: Perform a t-test\nA t-test is a statistical test used to compare the means of two groups. In our case, we want to compare the mean ΔCt values between the control and treatment groups.\nThe t-test is a valid test to use if the data in each group meets the following assumptions.\n\nThe data in each group is approximately normally distributed\nThe variance of the two groups is approximately equal\nThe two groups are independent of each other\n\nLater on, we will see how to check these assumptions and use alternative tests if they are not met. For now, we can assume that the data meets these assumptions:\n\nBox plots show approximately normal distribution\nVariance looks approximately equal\nThe two groups are independent (different samples in each group)\n\n\n\n Challenge:\n\nUse a t-test to decide if the mean values of Control and Treatment differ significantly.\n\nDoes the treatment have a significant effect on gene expression?\nDoes the treatment increase or decrease gene expression?\n\n\n\n\n\nSolution. \n\n Solution:\n\nUse a t-test to decide if the mean values of Control and Treatment differ more than would be expected by chance.\n\nt.test(delta_ct ~ Condition, data = qpcr, var.equal=TRUE)\n\n\n    Two Sample t-test\n\ndata:  delta_ct by Condition\nt = 11.391, df = 14, p-value = 1.821e-08\nalternative hypothesis: true difference in means between group Control and group Treatment is not equal to 0\n95 percent confidence interval:\n 1.268289 1.856711\nsample estimates:\n  mean in group Control mean in group Treatment \n                 5.0375                  3.4750 \n\n\n\nDoes the treatment have a significant effect on gene expression?\n\nThe p-value is less than 0.05, so we can reject the null hypothesis and conclude that there is a significant difference in gene expression between the control and treatment groups.\nYou can save the result of the t-test as an object and print the p-value:\n\nresult &lt;- t.test(delta_ct ~ Condition, data = qpcr, var.equal=TRUE)\nresult$p.value\n\n[1] 1.820703e-08\n\n\n\nDoes the treatment increase or decrease gene expression?\n\nThe mean ΔCt value for the treatment group is lower than the control group, which indicates that the treatment increases gene expression (remember that a lower ΔCt means higher expression).\n\n\n\n\n\n\nStep 5: Calculate fold change\nWe now know that there is a significant difference in gene expression between the control and treatment groups, but how much of a difference is there? We can calculate the fold change in gene expression using the formula:\n\\[\nFold~Change = 2^{-ΔΔCt}\n\\]\nTo calculate ΔΔCt, we need to subtract the mean ΔCt of the control group from the mean ΔCt of the treatment group.\n\nmean_control &lt;- mean(qpcr$delta_ct[qpcr$Condition == \"Control\"])\n\nmean_treatment &lt;- mean(qpcr$delta_ct[qpcr$Condition == \"Treatment\"])\n\ndelta_delta_ct &lt;- mean_treatment - mean_control\n\nNow we can calculate the fold change:\n\nfold_change &lt;- 2^(-delta_delta_ct)\nfold_change\n\n[1] 2.953652\n\n\nExpression is almost 3 times higher in the treatment group compared to the control group. When reporting this analysis, you should show the p-value and the fold change, as well as a visualisation of the data. The p-value tells us if the difference is statistically significant, while the fold change tells us how big the difference is (effect size).\nWe will revisit this case study in later modules to see how to do the same analysis using dedicated statistical and visualisation packages for high quality presentation."
  },
  {
    "objectID": "02-IntroR.html#summary",
    "href": "02-IntroR.html#summary",
    "title": "Introduction to R",
    "section": "Summary",
    "text": "Summary\nCongratulations! You have completed your first lesson in R. Hopefully you have a better understanding of what R is, its syntax and data types, and how to use it to import and analyse data.\nNext we will start to look at the strengths of R as a programming language and how to use it to write scripts that can be easily reproduced and shared with others.\n\n\n Resources\n\n\nR manual: https://cran.r-project.org/doc/manuals/r-patched/R-intro.html\nRStudio user guide: https://docs.posit.co/ide/user/\nRStudio cheat-sheet: https://rstudio.github.io/cheatsheets/html/rstudio-ide.html\n\n\n\n\n\n Key points\n\n\nR is a functional programming language for data science\nRStudio is an interactive environment for programming in R\nR has different data types and structures for organising data\nR code is run within functions, which have different arguments for customisation\nR functions can be used to import, manipulate and plot data\nThere are many functions for statistical analysis in R"
  },
  {
    "objectID": "02-Setup.html",
    "href": "02-Setup.html",
    "title": "Setup",
    "section": "",
    "text": "Project Setup\n\nCreate a new project in RStudio called Introduction to R.\nInstall the following packages:\n\n\ninstall.packages(\"read_excel\")"
  }
]